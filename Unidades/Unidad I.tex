\part{Unidad I}

\chapter{Programación Numérica}

La \textbf{programación numérica} es una disciplina que combina las matemáticas aplicadas y la informática con el objetivo de resolver problemas cuantitativos mediante métodos computacionales. Se centra en el diseño, análisis e implementación de algoritmos que permiten obtener soluciones aproximadas a ecuaciones, sistemas y modelos que, en la mayoría de los casos, no pueden resolverse de forma analítica \parencite{burden2016,chapra2015}.

A diferencia de la programación convencional, que busca desarrollar aplicaciones funcionales o sistemas de información, la programación numérica se orienta a la resolución eficiente y precisa de problemas matemáticos. Entre sus principales aplicaciones se encuentran la simulación de fenómenos físicos y biológicos, la modelización económica, la ingeniería de datos, la inteligencia artificial y el análisis estadístico en ciencias de la salud \parencite{press2007}.

El objetivo fundamental de esta área es transformar problemas continuos en representaciones discretas que puedan ser tratadas por un computador. De esta forma, se logra aproximar soluciones a problemas de optimización, integración, derivación, interpolación, ajuste de curvas y resolución de ecuaciones diferenciales.

En términos prácticos, la programación numérica permite al investigador o profesional:
\begin{itemize}
	\item Resolver ecuaciones no lineales mediante métodos iterativos.
	\item Aproximar derivadas e integrales de funciones cuando no se dispone de una forma analítica.
	\item Interpolar o ajustar funciones a datos experimentales.
	\item Optimizar funciones de una o varias variables bajo restricciones.
	\item Analizar errores y estimar la estabilidad numérica de los métodos empleados.
\end{itemize}

Actualmente, lenguajes como \texttt{Python}, \texttt{R}, \texttt{MATLAB} y \texttt{Julia} ofrecen bibliotecas especializadas que facilitan el desarrollo de algoritmos numéricos de alto rendimiento. Estos entornos han hecho posible que la programación numérica sea una herramienta accesible y poderosa para la investigación científica, la ingeniería y la docencia \parencite{chapra2015}.

En síntesis, la programación numérica constituye una base esencial para la solución computacional de problemas científicos y técnicos, integrando el razonamiento matemático con la capacidad de cómputo moderna.


\chapter{Funciones}

\section{Funciones a nuestro alrededor}

En casi todos los fenómenos físicos observamos que una cantidad depende de otra. Por ejemplo, la estatura de una persona depende de su edad, la temperatura de la fecha, el costo de enviar un paquete por correo depende de su peso. Usamos el término función para describir esta dependencia de una cantidad con respecto a otra. Esto es, decimos lo siguiente: \parencite{stewart_redlin_watson_precalculo}

\begin{itemize}
	\item La estatura es una función de la edad.
	\item La temperatura es una función de la fecha.
	\item El costo de enviar un paquete por correo depende de su peso.
\end{itemize}

\section{Definición de función}

\begin{tcolorbox}
	Una \textbf{función} $f$ es una regla que asigna a cada elemento x de un conjunto A exactamente un elemento, llamado $f(x)$, de un conjunto B.
\end{tcolorbox}

Para hablar de una función, es necesario darle un nombre. Usaremos letras como $f, g, h, ...$ para representar funciones. Por ejemplo, podemos usar la letra $f$ para representar una regla como sigue:

\begin{center}
	$"f"$ es la regla "elevar al cuadrado el número"
\end{center}

cuando escribimos $f(2)$ queremos decir "aplicar la regla f al número 2". La aplicación de la regla da $f(2) = 2^2 = 4$. Del mismo modo, $f(3) = 3^2 = 9, f(4) = 4^2 = 16$, y en general $f(x) = x^2$. \parencite{stewart_redlin_watson_precalculo}

Por lo general consideramos funciones para las cuales los conjuntos A y B son conjuntos de número reales. El símbolo $f(x)$ se lee "f de x" o "f en x" y se denomina \textbf{valor de $f$ en $x$}, o la \textbf{imagen de $x$ bajo $f$}. El conjunto A recibe el nombre de \textbf{dominio} de la función. El \textbf{rango} de $f$ es el conjunto de todos los valores posibles de $f(x)$ cuando $x$ varía en todo el dominio. El símbolo que representa un número arbitrario del dominio de una función $f$ se llama \textbf{variable independiente}. El símbolo que representa un número en el rango de $f$ se llama \textbf{variable dependiente}. Por tanto, si escribimos $y = f(x)$, entonces $x$ es la variable independiente y $y$ es la variable dependiente. \parencite{stewart_redlin_watson_precalculo}

Es útil considerar una función como una \hyperref[Diagramaflechasf]{\textbf{máquina}}. Si $x$ está en el dominio de la función $f$, entonces cuando $x$ entra a la máquina, es aceptada como \textbf{entrada} y la máquina produce una \textbf{salida} $f(x)$ de acuerdo con la regla de la función. Así, podemos considerar el dominio como el conjunto de todas las posibles entradas y el rango como el conjunto de todas las posibles salidas. \parencite{stewart_redlin_watson_precalculo}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Diagramaflechasf.png}
	\caption{Diagrama de flechas de $f$}
	\label{Diagramaflechasf}
\end{figure}

\section{Cuatro formas de representar una función}

Para entender mejor lo que es una función, podemos describir una función específica en las siguientes cuatro formas: \parencite{stewart_redlin_watson_precalculo}

\begin{itemize}
	\item verbalmente (por descripción en palabras)
	\item algebraicamente (por una fórmula explícita)
	\item visualmente (por una gráfica)
	\item numéricamente (por una tabla de valores)
\end{itemize}

Una función individual puede estar representada en las cuatro formas, y con frecuencia es útil pasar de una representación a otra para adquirir más conocimientos sobre la función. No obstante, ciertas funciones se describen en forma más natural por medio de un método que por los otros. Un ejemplo de una descripción verbal es la siguiente regla para convertir entres escalas de temperatura: \parencite{stewart_redlin_watson_precalculo}

\begin{center}
	"Para hallar el equivalente Fahrenheit de una temperatura Celsius, multiplicar por $\dfrac{9}{5}$ la temperatura Celsius y luego sumar 32"
\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Representacionfunciones.png}
	\caption{Cuatro formas de representar una función}
	\label{Formasfunciones}
\end{figure}

\section{Gráficas de funciones}

\subsection{Gráficas de funciones por localización de puntos}

Para graficar una función $f$ localizamos los puntos $(x,f(x))$ en un plano de coordenadas. En otras palabras, localizamos los puntos $(x,y)$ cuya coordenada $x$ es una entrada y cuya coordenada $y$ es la correspondiente salida de la función. \parencite{stewart_redlin_watson_precalculo}

\begin{tcolorbox}
	Si $f$ es una función con dominio A, entonces la \textbf{gráfica} de $f$ es el conjunto de pares ordenados
	\begin{center}
		$(x, f(x)) | x \in A$
	\end{center}
	localizados en un plano de coordendas. En otras palabras, la gráfica de $f$ es el conjunto de todos los puntos $(x,y)$ tales que $y = f(x)$; esto es, la gráfica de f es la gráfica de la ecuación $y = f(x)$.
\end{tcolorbox}

La gráfica de una función $f$ da un retrato del comportamiento o "historia de la vida" de la función. Podemos leer el valor de $f(x)$ a partir de la gráfica como la altura de la gráfica arriba del punto $x$. \parencite{stewart_redlin_watson_precalculo}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Alturadegrafica.png}
	\caption{La altura de la gráfica arriba del punto x es el valor de $f(x)$}
	\label{Alturadegrafica}
\end{figure}

Una función $f$ de la forma $f(x) = mx + b$ se denomina \textbf{función lineal} porque su gráfica es la gráfica de la ecuación $y = mx + b$, que representa una recta con pendiente $m$ y punto de intersección $b$ en $y$. Un caso especial de una función lineal se presenta cuando la pendiente es m = 0. La función $f(x) = b$, donde $b$ es un número determinado, recibe el nombre de $función constante$ porque todos sus valores son el mismo número, es decir, $b$. Su gráfica es la recta horizontal $y = b$. \parencite{stewart_redlin_watson_precalculo}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Funcionlicon.png}
	\caption{Funciones lineal y constante}
	\label{Funcionlinealconst}
\end{figure}

\subsection{La prueba de la recta vertical}

La gráfica de una función es una curva en el plano $xy$. Pero surge la pregunta. ¿Cuáles curvas del plano $xy$ son gráficas de funciones? ESto se contesta por medio de la prueba siguiente. \parencite{stewart_redlin_watson_precalculo}

\begin{tcolorbox}
	Una curva en el plano de coordenadas es la gráfica de una función si y sólo si ninguna recta vertical cruza la curva más de una vez.
\end{tcolorbox}

Podemos ver la \hyperref[Pruebavertical]{\textbf{Figura~\ref*{Pruebavertical}}} para entender por qué la Prueba de la Recta Vertical es verdadera. 
Si cada recta vertical \(x = a\) cruza la curva sólo una vez en \((a,b)\), entonces exactamente un valor funcional está definido por \(f(a) = b\). 
Pero si una recta \(x = a\) cruza la curva dos veces, en \((a,b)\) y en \((a,c)\), entonces la curva no puede representar una función 
porque una función no puede asignar dos valores diferentes a \(a\).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Pruebavertical.png}
	\caption{Prueba de la recta vertical}
	\label{Pruebavertical}
\end{figure}

\section{Aplicación}

Se presentará un código en \textbf{Python} que sea capaz de graficar funciones, según los datos de entrada que se pidan.

\begin{pythoncode}
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# === Ingreso de la función por el usuario ===
expr_str = input("Ingrese la función en términos de x (ejemplo: sin(x), x**2 + 3*x - 5, exp(-x)*cos(x)): ")

# === Definición de variable simbólica ===
x = sp.Symbol('x')

# === Conversión del texto a expresión simbólica ===
try:
expr = sp.sympify(expr_str)
except sp.SympifyError:
print("Error: la función ingresada no es válida.")
exit()

# === Creación de función numérica evaluable ===
f = sp.lambdify(x, expr, modules=['numpy'])

# === Intervalo de graficación ===
x_vals = np.linspace(-10, 10, 400)
y_vals = f(x_vals)

# === Graficar ===
plt.figure(figsize=(7,5))
plt.plot(x_vals, y_vals, label=f"$f(x) = {sp.latex(expr)}$", color='navy')
plt.title("Gráfica de la función ingresada", fontsize=13)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True, linestyle='--', alpha=0.6)
plt.axhline(0, color='black', linewidth=1)
plt.axvline(0, color='black', linewidth=1)
plt.legend()
plt.show()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/FunPython.png}
	\caption{Graficando funciones con Python}
	\label{FunPy}
\end{figure}

\chapter{Restricciones}

Las restricciones son condiciones que limitan el conjunto de valores posibles que pueden tomar las variables en un problema matemático. Estas limitaciones definen el espacio factible o región factible, dentro del cual se busca una o más soluciones que cumplan con determinados criterios. Las restricciones pueden ser igualdades (por ejemplo, $x + y = 10$) o desigualdades (por ejemplo, $x \ge 0$), y desempeñan un papel fundamental en los problemas de optimización, programación lineal y análisis numérico.
\parencite{chapra_canale_metodos, burden_faires_analisis, anton_bivens_davis_calculo}

Un sistema de ecuaciones consiste en un conjunto de ecuaciones que comparten las mismas variables. Resolverlo implica encontrar los valores que satisfacen todas las ecuaciones simultáneamente. Estos sistemas pueden clasificarse en lineales y no lineales, y sus métodos de resolución varían desde técnicas algebraicas clásicas (como la sustitución o igualación) hasta procedimientos numéricos avanzados (como el método de Gauss-Seidel o Newton-Raphson).
\parencite{chapra_canale_metodos, riley_hobson_bence_mathematical, burden_faires_analisis}

En el contexto de la programación numérica, las restricciones se representan y manipulan mediante código, permitiendo no solo resolver el sistema de ecuaciones sino también visualizar gráficamente la región factible y el punto óptimo. Esta representación es especialmente útil para comprender la interacción entre las ecuaciones y las limitaciones impuestas, facilitando el análisis y la toma de decisiones en problemas aplicados de ingeniería, economía y ciencias computacionales.
\parencite{stewart_redlin_watson_precalculo, chapra_canale_metodos}

\section{Ejemplo}

Un desarrollador tiene 15 horas semanales para dedicar al desarrollo de software de front-end (x) y back-end (y). Además:

\begin{itemize}
	\item Debe dedicar al menos 5 horas al desarrollo de front-end para cumplir con los entregables del cliente.
	\item El tiempo total no puede exceder 15 horas por restricciones de tiempo del sprint.
\end{itemize}

Formule las restricciones, represéntelas gráficamente e identifique las combinaciones posibles de tiempo a invertir en cada actividad.

\textbf{Variables}

\begin{itemize}
	\item x = horas dedicadas al front-end
	\item y = horas dedicadas al back-end
\end{itemize}

\textbf{Restricciones}

\begin{enumerate}
	\item Debe dedicar al menos 5 horas al mes.
	\begin{itemize}
		\item $x \geq 5$
	\end{itemize}
	\item El tiempo total no puede exceder a 15 horas.
	\begin{itemize}
		\item $x + y \leq 15 $
	\end{itemize}
\end{enumerate}

\textbf{Gráfico generado con python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio1.png}
	\caption{Aplicación de restricciones en Python}
	\label{EjemploRestriccion}
\end{figure}

\textbf{Interpretación del gráfico}

En la representación gráfica se observa la región factible determinada por las restricciones planteadas:

\begin{itemize}
	\item $x \geq 5$: el desarrollador debe dedicar al menos 5 horas al front-end. Esta condición aparece como una línea vertical en $x=5$ y la región válida se encuentra a la derecha de ella.
	\item $y \geq 0$: el tiempo dedicado al back-end no puede ser negativo, por lo que la región se limita a la parte superior del eje $x$.
	\item $x + y \leq 15$: la suma de horas asignadas a front-end y back-end no puede superar las 15 horas semanales. Gráficamente, corresponde a la semirrecta bajo la línea $x+y=15$.
\end{itemize}

La intersección de estas tres restricciones genera una región triangular factible delimitada por los puntos $(5,0)$, $(15,0)$ y $(5,10)$. Esto significa que cualquier combinación de horas ubicada dentro o sobre este triángulo cumple con las condiciones del problema. Por ejemplo, el desarrollador podría dedicar:
\begin{itemize}
	\item 5 horas a front-end y 10 horas a back-end,
	\item 10 horas a front-end y 5 horas a back-end,
	\item o bien 15 horas únicamente a front-end.
\end{itemize}

En conclusión, la región sombreada representa todas las combinaciones posibles de tiempo de trabajo entre front-end y back-end que respetan tanto el mínimo requerido en front-end como la restricción máxima de 15 horas semanales.

\textbf{Código en Python}

\begin{pythoncode}
	# Función para preparar expresiones lineales
def preparar_expresion(expr: str) -> str:
expr = expr.replace(" ", "")          # quitar espacios
expr = expr.replace("^", "**")        # potencia
expr = expr.replace("-x", "-1*x")     # caso -x
expr = expr.replace("+x", "+1*x")     # caso +x
if expr.startswith("x"):              # si empieza con x
expr = "1*" + expr
expr = expr.replace("x", "*x")        # poner multiplicación
expr = expr.replace("**x", "*x")      # corregir si se duplicó
return expr

# Restricciones:
# 1) x = 5  (vertical)
# 2) x + y = 15  ->  y = -x + 15
func2 = preparar_expresion("-x+15")

# Rango de la gráfica
xmin, xmax = -5, 20
ymin, ymax = -5, 20

# Recorremos el plano
for y in range(ymax, ymin - 1, -1):
linea = ""
for x in range(xmin, xmax + 1):
# Recta 1: x = 5
cond1 = (x == 5)

# Recta 2: y = -x + 15
try:
y2 = eval(func2)
except:
y2 = None
cond2 = (y2 is not None and abs(y - y2) < 0.5)

# Región factible: x>=5, y>=0, x+y<=15
region = (x >= 5 and y >= 0 and x + y <= 15)

# Qué dibujar
if cond1 and cond2:
linea += "#"
elif cond1:
linea += "*"
elif cond2:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
elif region:
linea += "."
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = x = 5")
print("  o = x + y = 15")
print("  # = Intersección")
print("  . = Región factible")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\chapter{Método de Newton Raphson}

El \textbf{método de Newton-Raphson} es una técnica iterativa utilizada para encontrar raíces de ecuaciones no lineales de la forma:
\[
f(x) = 0
\]
Es uno de los métodos más eficaces y ampliamente utilizados debido a su rapidez de convergencia cuando se cumplen las condiciones necesarias. Fue propuesto originalmente por Isaac Newton y posteriormente generalizado por Joseph Raphson \parencite{chapra_canale_newton}.

\section{Fundamento teórico}

La idea básica del método consiste en aproximar la función $f(x)$ mediante su expansión de Taylor alrededor de un punto $x_i$ y despreciar los términos de orden superior:
\[
f(x) \approx f(x_i) + f'(x_i)(x - x_i)
\]

Para hallar la raíz, se hace $f(x) = 0$, y despejando $x$ se obtiene la fórmula iterativa:
\[
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
\]

Esta expresión permite calcular una mejor aproximación de la raíz en cada iteración. El proceso continúa hasta que el valor de $x_{i+1}$ converge a la raíz real con una tolerancia previamente establecida \parencite{chapra_canale_newton}.

\section{Condiciones de convergencia}

El método de Newton-Raphson presenta convergencia cuadrática, es decir, el error disminuye aproximadamente al cuadrado en cada iteración, siempre que se cumplan las siguientes condiciones \parencite{suli_mayers_2003}:

\begin{itemize}
	\item La función $f(x)$ es continua y derivable en un intervalo que contiene la raíz buscada.
	\item La derivada $f'(x)$ no se anula en el entorno de la raíz.
	\item La estimación inicial $x_0$ está suficientemente cerca de la raíz real.
\end{itemize}

Sin embargo, si $f'(x_i)$ se aproxima a cero o si la estimación inicial está muy alejada, el método puede divergir o generar oscilaciones \parencite{burden_faires_2011}.

\section{Criterio de parada}

El proceso iterativo se detiene cuando se cumple alguna de las siguientes condiciones \parencite{chapra_canale_newton}:

\begin{itemize}
	\item $|f(x_{i+1})| < \varepsilon$
	\item $|x_{i+1} - x_i| < \varepsilon$
\end{itemize}

donde $\varepsilon$ es la \textit{tolerancia} o el error máximo permitido.

\section{Algoritmo del método de Newton-Raphson}

\begin{tcolorbox}
	\begin{enumerate}
		\item Elegir una estimación inicial $x_0$.
		\item Calcular $f(x_0)$ y $f'(x_0)$.
		\item Evaluar:
		\[
		x_{1} = x_0 - \frac{f(x_0)}{f'(x_0)}
		\]
		\item Repetir el proceso:
		\[
		x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
		\]
		hasta que se cumpla el criterio de convergencia.
	\end{enumerate}
\end{tcolorbox}

\section{Aplicación del método en Python}

El objetivo fue desarrollar en el lenguaje de programación Python un programa que permita al usuario ingresar una función $f(x)$ y graficarla en un intervalo definido. Esta etapa inicial tiene como propósito ayudar al usuario a identificar visualmente las posibles raíces y decidir si desea aplicar el método de Newton-Raphson.

En caso afirmativo, el programa solicita un valor inicial $x_1$ basado en la observación de la gráfica y ejecuta el algoritmo iterativo de Newton-Raphson hasta que la diferencia entre dos aproximaciones sucesivas sea menor a una tolerancia predefinida. Finalmente, el programa muestra en pantalla la raíz aproximada encontrada y el número de iteraciones necesarias para alcanzarla.

Este enfoque combina la interpretación gráfica con el análisis numérico, promoviendo una comprensión más completa del comportamiento de la función y de la eficacia del método iterativo.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para evaluar si realizar o no el método.
	\item La raíz encontrada.
	\item Número de iteraciones realizadas hasta encontrar la raíz.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función y su derivada (usando derivada numérica)
def f(x):
return eval(func_str)

def f_prime(x, h=1e-6):  # derivada numérica
return (f(x + h) - f(x - h)) / (2 * h)

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar Newton-Raphson ===
op = input("¿Desea encontrar una raíz con el método de Newton-Raphson? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de punto inicial ===
x0 = float(input("Basado en la gráfica, ingrese el valor inicial x1: "))

# Parámetros del método
tol = 1e-6
max_iter = 100

# Iteraciones
for i in range(1, max_iter + 1):
fx = f(x0)
fpx = f_prime(x0)

if fpx == 0:
print(f"La derivada es cero en x = {x0}. El método no puede continuar.")
break

x1 = x0 - fx / fpx

# Verificar convergencia
if abs(x1 - x0) < tol:
print(f"\n✅ Raíz aproximada encontrada: {x1:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0 = x1
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")

else:
print("No se aplicó el método de Newton-Raphson.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon2.png}
	\caption{Método de Newthon-Rapshon en Python}
	\label{Newthon-R}
\end{figure}

\chapter{Método de Bisección}

\chapter{Método de la Secante}

\chapter{Método de Punto Fijo}

\chapter{Método de Regula Falsi}