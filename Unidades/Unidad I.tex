\part{Unidad I}

\chapter{Programación Numérica}

La \textbf{programación numérica} es una disciplina que combina las matemáticas aplicadas y la informática con el objetivo de resolver problemas cuantitativos mediante métodos computacionales. Se centra en el diseño, análisis e implementación de algoritmos que permiten obtener soluciones aproximadas a ecuaciones, sistemas y modelos que, en la mayoría de los casos, no pueden resolverse de forma analítica \parencite{burden2016,chapra2015}.

A diferencia de la programación convencional, que busca desarrollar aplicaciones funcionales o sistemas de información, la programación numérica se orienta a la resolución eficiente y precisa de problemas matemáticos. Entre sus principales aplicaciones se encuentran la simulación de fenómenos físicos y biológicos, la modelización económica, la ingeniería de datos, la inteligencia artificial y el análisis estadístico en ciencias de la salud \parencite{press2007}.

El objetivo fundamental de esta área es transformar problemas continuos en representaciones discretas que puedan ser tratadas por un computador. De esta forma, se logra aproximar soluciones a problemas de optimización, integración, derivación, interpolación, ajuste de curvas y resolución de ecuaciones diferenciales.

En términos prácticos, la programación numérica permite al investigador o profesional:
\begin{itemize}
	\item Resolver ecuaciones no lineales mediante métodos iterativos.
	\item Aproximar derivadas e integrales de funciones cuando no se dispone de una forma analítica.
	\item Interpolar o ajustar funciones a datos experimentales.
	\item Optimizar funciones de una o varias variables bajo restricciones.
	\item Analizar errores y estimar la estabilidad numérica de los métodos empleados.
\end{itemize}

Actualmente, lenguajes como \texttt{Python}, \texttt{R}, \texttt{MATLAB} y \texttt{Julia} ofrecen bibliotecas especializadas que facilitan el desarrollo de algoritmos numéricos de alto rendimiento. Estos entornos han hecho posible que la programación numérica sea una herramienta accesible y poderosa para la investigación científica, la ingeniería y la docencia \parencite{chapra2015}.

En síntesis, la programación numérica constituye una base esencial para la solución computacional de problemas científicos y técnicos, integrando el razonamiento matemático con la capacidad de cómputo moderna.

\section{Ejemplo}

Utilizando la programación numérica desarrollar una aplicación que permita analizar operaciones matemáticas (Identificador de funciones). 

\begin{pythoncode}
import re

def analizar_funcion(funcion):
funcion = funcion.replace(" ", "")
variables = sorted(set(re.findall(r'[a-zA-Z]', funcion)))
terminos = re.findall(r'[+-]?\d*[a-zA-Z]?\^?\d*', funcion)
terminos = [t for t in terminos if t]
coeficientes = []
signos = []
for t in terminos:
if t.startswith('-'):
signos.append('-')
else:
signos.append('+')
c = re.findall(r'[+-]?\d+', t)
if c:
coef = int(c[0])
else:
coef = -1 if t.startswith('-') else 1
coeficientes.append(coef)
print(f"\n   Función ingresada: {funcion}")
print(f"   Variables encontradas: {variables}")
print(f"   Términos: {terminos}")
print(f"   Coeficientes: {coeficientes}")
print(f"   Signos: {signos}")

print("=== ANALIZADOR DE FUNCIONES ALGEBRAICAS ===")
funcion = input("   Ingresa una función (ejemplo: 3x^2 - 4x + 7): ")
analizar_funcion(funcion)
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Analizador de funciones1.png}
	\caption{Analizador de funciones}
	\label{Analizador de funciones}
\end{figure}

\textbf{Explicación}

El problema se resolvió utilizando el lenguaje de programación \textbf{Python} y el módulo \texttt{re} (expresiones regulares), que permite analizar y extraer patrones dentro de una cadena de texto.

\textbf{1. Limpieza de la función}

\begin{verbatim}
	funcion = funcion.replace(" ", "")
\end{verbatim}

Se eliminan los espacios en blanco para facilitar el análisis de la expresión algebraica.

\textbf{2. Identificación de variables}

\begin{verbatim}
	variables = sorted(set(re.findall(r'[a-zA-Z]', funcion)))
\end{verbatim}

\begin{itemize}
	\item Se usa una expresión regular para encontrar todas las letras.
	\item Se eliminan duplicados con \texttt{set}.
	\item Se ordenan alfabéticamente.
\end{itemize}

\textbf{3. Separación de términos algebraicos}

\begin{verbatim}
	terminos = re.findall(r'[+-]?\d*[a-zA-Z]?\^?\d*', funcion)
	terminos = [t for t in terminos if t]
\end{verbatim}

Se extraen los términos considerando:

\begin{itemize}
	\item Signo opcional (\texttt{+} o \texttt{-})
	\item Coeficiente numérico
	\item Variable
	\item Potencia (si existe)
\end{itemize}

\textbf{4. Obtención de coeficientes y signos}

\begin{verbatim}
	for t in terminos:
	if t.startswith('-'):
	signos.append('-')
	else:
	signos.append('+')
\end{verbatim}

Se determina el signo de cada término.

\begin{verbatim}
	c = re.findall(r'[+-]?\d+', t)
	if c:
	coef = int(c[0])
	else:
	coef = -1 if t.startswith('-') else 1
\end{verbatim}

\begin{itemize}
	\item Si hay número explícito, se toma como coeficiente.
	\item Si no hay número, se asume \texttt{1} o \texttt{-1}.
\end{itemize}

\textbf{5. Presentación de resultados}

\begin{verbatim}
	print(f"   Función ingresada: {funcion}")
	print(f"   Variables encontradas: {variables}")
	print(f"   Términos: {terminos}")
	print(f"   Coeficientes: {coeficientes}")
	print(f"   Signos: {signos}")
\end{verbatim}

\textbf{Objetivo del código}

El objetivo principal de este programa es analizar una función algebraica ingresada por el usuario y extraer sus componentes fundamentales, específicamente:

\begin{itemize}
	\item Identificar las variables presentes en la función.
	\item Separar la función en términos algebraicos.
	\item Determinar los coeficientes numéricos de cada término.
	\item Reconocer el signo (positivo o negativo) de cada término.
\end{itemize}

Este análisis es útil como paso previo en aplicaciones como:

\begin{itemize}
	\item Simplificación de expresiones algebraicas.
	\item Derivación e integración simbólica.
	\item Clasificación de polinomios.
	\item Desarrollo de software educativo matemático.
\end{itemize}

\textbf{Código en Python usando Tkinter}

\begin{pythoncode}
import re
import tkinter as tk
from tkinter import messagebox

def analizar_funcion():
funcion = entrada_funcion.get().replace(" ", "")

if not funcion:
messagebox.showwarning("Advertencia", "Ingrese una función algebraica")
return

variables = sorted(set(re.findall(r'[a-zA-Z]', funcion)))
terminos = re.findall(r'[+-]?\d*[a-zA-Z]?\^?\d*', funcion)
terminos = [t for t in terminos if t]

coeficientes = []
signos = []

for t in terminos:
if t.startswith('-'):
signos.append('-')
else:
signos.append('+')

c = re.findall(r'[+-]?\d+', t)
if c:
coef = int(c[0])
else:
coef = -1 if t.startswith('-') else 1

coeficientes.append(coef)

salida.config(state="normal")
salida.delete("1.0", tk.END)
salida.insert(tk.END, f"   Función ingresada: {funcion}\n")
salida.insert(tk.END, f"   Variables encontradas: {variables}\n")
salida.insert(tk.END, f"   Términos: {terminos}\n")
salida.insert(tk.END, f"   Coeficientes: {coeficientes}\n")
salida.insert(tk.END, f"   Signos: {signos}\n")
salida.config(state="disabled")

ventana = tk.Tk()
ventana.title("Analizador de Funciones Algebraicas")
ventana.geometry("500x400")
ventana.resizable(False, False)

titulo = tk.Label(
ventana,
text="ANALIZADOR DE FUNCIONES ALGEBRAICAS",
font=("Arial", 14, "bold")
)
titulo.pack(pady=10)

label_funcion = tk.Label(
ventana,
text="Ingrese la función (ejemplo: 3x^2 - 4x + 7):"
)
label_funcion.pack()

entrada_funcion = tk.Entry(
ventana,
width=40,
font=("Arial", 12)
)
entrada_funcion.pack(pady=5)

boton = tk.Button(
ventana,
text="Analizar función",
font=("Arial", 11),
command=analizar_funcion
)
boton.pack(pady=10)

salida = tk.Text(
ventana,
height=10,
width=55,
state="disabled",
font=("Consolas", 10)
)
salida.pack(pady=10)

ventana.mainloop()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Analizador.png}
	\caption{Analizador de funciones con Tkinter}
	\label{Analizador de funciones2}
\end{figure}

\chapter{Funciones}

\section{Funciones a nuestro alrededor}

En casi todos los fenómenos físicos observamos que una cantidad depende de otra. Por ejemplo, la estatura de una persona depende de su edad, la temperatura de la fecha, el costo de enviar un paquete por correo depende de su peso. Usamos el término función para describir esta dependencia de una cantidad con respecto a otra. Esto es, decimos lo siguiente: \parencite{stewart2001}

\begin{itemize}
	\item La estatura es una función de la edad.
	\item La temperatura es una función de la fecha.
	\item El costo de enviar un paquete por correo depende de su peso.
\end{itemize}

\section{Definición de función}

\begin{tcolorbox}
	Una \textbf{función} $f$ es una regla que asigna a cada elemento x de un conjunto A exactamente un elemento, llamado $f(x)$, de un conjunto B.
\end{tcolorbox}

Para hablar de una función, es necesario darle un nombre. Usaremos letras como $f, g, h, ...$ para representar funciones. Por ejemplo, podemos usar la letra $f$ para representar una regla como sigue:

\begin{center}
	$"f"$ es la regla "elevar al cuadrado el número"
\end{center}

cuando escribimos $f(2)$ queremos decir "aplicar la regla f al número 2". La aplicación de la regla da $f(2) = 2^2 = 4$. Del mismo modo, $f(3) = 3^2 = 9, f(4) = 4^2 = 16$, y en general $f(x) = x^2$. \parencite{stewart2001}

Por lo general consideramos funciones para las cuales los conjuntos A y B son conjuntos de número reales. El símbolo $f(x)$ se lee "f de x" o "f en x" y se denomina \textbf{valor de $f$ en $x$}, o la \textbf{imagen de $x$ bajo $f$}. El conjunto A recibe el nombre de \textbf{dominio} de la función. El \textbf{rango} de $f$ es el conjunto de todos los valores posibles de $f(x)$ cuando $x$ varía en todo el dominio. El símbolo que representa un número arbitrario del dominio de una función $f$ se llama \textbf{variable independiente}. El símbolo que representa un número en el rango de $f$ se llama \textbf{variable dependiente}. Por tanto, si escribimos $y = f(x)$, entonces $x$ es la variable independiente y $y$ es la variable dependiente. \parencite{stewart2001}

Es útil considerar una función como una \hyperref[Diagramaflechasf]{\textbf{máquina}}. Si $x$ está en el dominio de la función $f$, entonces cuando $x$ entra a la máquina, es aceptada como \textbf{entrada} y la máquina produce una \textbf{salida} $f(x)$ de acuerdo con la regla de la función. Así, podemos considerar el dominio como el conjunto de todas las posibles entradas y el rango como el conjunto de todas las posibles salidas. \parencite{stewart2001}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Diagramaflechasf.png}
	\caption{Diagrama de flechas de $f$}
	\label{Diagramaflechasf}
\end{figure}

\section{Cuatro formas de representar una función}

Para entender mejor lo que es una función, podemos describir una función específica en las siguientes cuatro formas: \parencite{stewart2016}

\begin{itemize}
	\item verbalmente (por descripción en palabras)
	\item algebraicamente (por una fórmula explícita)
	\item visualmente (por una gráfica)
	\item numéricamente (por una tabla de valores)
\end{itemize}

Una función individual puede estar representada en las cuatro formas, y con frecuencia es útil pasar de una representación a otra para adquirir más conocimientos sobre la función. No obstante, ciertas funciones se describen en forma más natural por medio de un método que por los otros. Un ejemplo de una descripción verbal es la siguiente regla para convertir entres escalas de temperatura: \parencite{stewart2016}

\begin{center}
	"Para hallar el equivalente Fahrenheit de una temperatura Celsius, multiplicar por $\dfrac{9}{5}$ la temperatura Celsius y luego sumar 32"
\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Representacionfunciones.png}
	\caption{Cuatro formas de representar una función}
	\label{Formasfunciones}
\end{figure}

\section{Gráficas de funciones}

\subsection{Gráficas de funciones por localización de puntos}

Para graficar una función $f$ localizamos los puntos $(x,f(x))$ en un plano de coordenadas. En otras palabras, localizamos los puntos $(x,y)$ cuya coordenada $x$ es una entrada y cuya coordenada $y$ es la correspondiente salida de la función. \parencite{stewart2016}

\begin{tcolorbox}
	Si $f$ es una función con dominio A, entonces la \textbf{gráfica} de $f$ es el conjunto de pares ordenados
	\begin{center}
		$(x, f(x)) | x \in A$
	\end{center}
	localizados en un plano de coordendas. En otras palabras, la gráfica de $f$ es el conjunto de todos los puntos $(x,y)$ tales que $y = f(x)$; esto es, la gráfica de f es la gráfica de la ecuación $y = f(x)$.
\end{tcolorbox}

La gráfica de una función $f$ da un retrato del comportamiento o "historia de la vida" de la función. Podemos leer el valor de $f(x)$ a partir de la gráfica como la altura de la gráfica arriba del punto $x$. \parencite{stewart2016}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Alturadegrafica.png}
	\caption{La altura de la gráfica arriba del punto x es el valor de $f(x)$}
	\label{Alturadegrafica}
\end{figure}

Una función $f$ de la forma $f(x) = mx + b$ se denomina \textbf{función lineal} porque su gráfica es la gráfica de la ecuación $y = mx + b$, que representa una recta con pendiente $m$ y punto de intersección $b$ en $y$. Un caso especial de una función lineal se presenta cuando la pendiente es m = 0. La función $f(x) = b$, donde $b$ es un número determinado, recibe el nombre de función constante porque todos sus valores son el mismo número, es decir, $b$. Su gráfica es la recta horizontal $y = b$. \parencite{stewart2016}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Funcionlicon.png}
	\caption{Funciones lineal y constante}
	\label{Funcionlinealconst}
\end{figure}

\subsection{La prueba de la recta vertical}

La gráfica de una función es una curva en el plano $xy$. Pero surge la pregunta. ¿Cuáles curvas del plano $xy$ son gráficas de funciones? Esto se contesta por medio de la prueba siguiente. \parencite{stewart2016}

\begin{tcolorbox}
	Una curva en el plano de coordenadas es la gráfica de una función si y sólo si ninguna recta vertical cruza la curva más de una vez.
\end{tcolorbox}

Podemos ver la \hyperref[Pruebavertical]{\textbf{Figura~\ref*{Pruebavertical}}} para entender por qué la Prueba de la Recta Vertical es verdadera. 
Si cada recta vertical \(x = a\) cruza la curva sólo una vez en \((a,b)\), entonces exactamente un valor funcional está definido por \(f(a) = b\). 
Pero si una recta \(x = a\) cruza la curva dos veces, en \((a,b)\) y en \((a,c)\), entonces la curva no puede representar una función 
porque una función no puede asignar dos valores diferentes a \(a\).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Pruebavertical.png}
	\caption{Prueba de la recta vertical}
	\label{Pruebavertical}
\end{figure}

\section{Aplicación 1}

Se presentará un código en \textbf{Python} que sea capaz de graficar funciones, según los datos de entrada que se pidan.

\begin{pythoncode}
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# === Ingreso de la función por el usuario ===
expr_str = input("Ingrese la función en términos de x (ejemplo: sin(x), x**2 + 3*x - 5, exp(-x)*cos(x)): ")

# === Definición de variable simbólica ===
x = sp.Symbol('x')

# === Conversión del texto a expresión simbólica ===
try:
expr = sp.sympify(expr_str)
except sp.SympifyError:
print("Error: la función ingresada no es válida.")
exit()

# === Creación de función numérica evaluable ===
f = sp.lambdify(x, expr, modules=['numpy'])

# === Intervalo de graficación ===
x_vals = np.linspace(-10, 10, 400)
y_vals = f(x_vals)

# === Graficar ===
plt.figure(figsize=(7,5))
plt.plot(x_vals, y_vals, label=f"$f(x) = {sp.latex(expr)}$", color='navy')
plt.title("Gráfica de la función ingresada", fontsize=13)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True, linestyle='--', alpha=0.6)
plt.axhline(0, color='black', linewidth=1)
plt.axvline(0, color='black', linewidth=1)
plt.legend()
plt.show()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/FunPython.png}
	\caption{Graficar funciones}
	\label{FunPython}
\end{figure}

\section{Aplicación 2}

Se presentará un código en \textbf{Python} que sea capaz de graficar 2 funciones lineales.

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-10, 10, 100)

y1 = 2 * x + 3
y2 = -1 * x + 5

plt.figure(figsize=(8, 6))
plt.plot(x, y1, label='f₁(x) = 2x + 3', color='blue', linewidth=2)
plt.plot(x, y2, label='f₂(x) = -x + 5', color='red', linewidth=2)

plt.title('Gráfico de dos funciones lineales')
plt.xlabel('Eje X')
plt.ylabel('Eje Y')
plt.grid(True, linestyle='--', alpha=0.6)
plt.legend()
plt.axhline(0, color='black', linewidth=1)
plt.axvline(0, color='black', linewidth=1)

plt.show()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Funcioneslineales1.png}
	\caption{Graficar 2 funciones lineales}
	\label{Lineales}
\end{figure}

\textbf{Explicación}

\textbf{1. Importación de librerías}

\begin{verbatim}
	import numpy as np
	import matplotlib.pyplot as plt
\end{verbatim}

NumPy se utiliza para crear arreglos numéricos y manejar datos de forma eficiente.  
Matplotlib permite generar gráficos científicos en dos dimensiones.

\textbf{2. Definición del rango de valores}

\begin{verbatim}
	x = np.linspace(-10, 10, 100)
\end{verbatim}

Se genera un arreglo de 100 valores equidistantes en el intervalo $[-10,10]$.  
Estos valores representan el dominio sobre el cual se evaluarán las funciones.

\textbf{3. Definición de las funciones lineales}

Se definen dos funciones lineales:

\begin{itemize}
	\item $f_1(x) = 2x + 3$: pendiente positiva, función creciente.
	\item $f_2(x) = -x + 5$: pendiente negativa, función decreciente.
\end{itemize}

Cada función se evalúa para todos los valores del arreglo $x$.

\textbf{4. Creación del gráfico}

\begin{verbatim}
	plt.figure(figsize=(8, 6))
	plt.plot(x, y1, label='f₁(x) = 2x + 3', color='blue', linewidth=2)
	plt.plot(x, y2, label='f₂(x) = -x + 5', color='red', linewidth=2)
\end{verbatim}

Se crea una figura y se grafican ambas funciones con diferentes colores y etiquetas para distinguirlas visualmente.

\textbf{5. Personalización del gráfico}

\begin{verbatim}
	plt.title('Gráfico de dos funciones lineales')
	plt.xlabel('Eje X')
	plt.ylabel('Eje Y')
	plt.grid(True, linestyle='--', alpha=0.6)
	plt.legend()
	plt.axhline(0)
	plt.axvline(0)
\end{verbatim}

\textbf{6. Visualización final}

\begin{verbatim}
	plt.show()
\end{verbatim}

\textbf{Objetivo del código}

El objetivo del programa es representar gráficamente funciones lineales para analizar su comportamiento, permitiendo observar la pendiente, el crecimiento o decrecimiento y la intersección con los ejes coordenados.

\textbf{Código en Python usando Tkinter}

\begin{pythoncode}
import tkinter as tk
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

def graficar():
x = np.linspace(-10, 10, 100)
y1 = 2 * x + 3
y2 = -1 * x + 5

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(x, y1, label='f₁(x) = 2x + 3', linewidth=2)
ax.plot(x, y2, label='f₂(x) = -x + 5', linewidth=2)

ax.set_title("Gráfico de dos funciones lineales")
ax.set_xlabel("Eje X")
ax.set_ylabel("Eje Y")
ax.axhline(0)
ax.axvline(0)
ax.grid(True)
ax.legend()

canvas = FigureCanvasTkAgg(fig, master=ventana)
canvas.draw()
canvas.get_tk_widget().pack(pady=10)

ventana = tk.Tk()
ventana.title("Gráfico de funciones lineales")
ventana.geometry("700x500")

titulo = tk.Label(
ventana,
text="GRÁFICO DE FUNCIONES LINEALES",
font=("Arial", 14, "bold")
)
titulo.pack(pady=10)

boton = tk.Button(
ventana,
text="Mostrar gráfica",
font=("Arial", 11),
command=graficar
)
boton.pack(pady=5)

ventana.mainloop()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Graficadorlineal.png}
	\caption{Graficador de 2 funciones lineales con Tkinter}
	\label{Graficador2}
\end{figure}

\chapter{Restricciones}

Las restricciones son condiciones que limitan el conjunto de valores posibles que pueden tomar las variables en un problema matemático. Estas limitaciones definen el espacio factible o región factible, dentro del cual se busca una o más soluciones que cumplan con determinados criterios. Las restricciones pueden ser igualdades (por ejemplo, $x + y = 10$) o desigualdades (por ejemplo, $x \ge 0$), y desempeñan un papel fundamental en los problemas de optimización, programación lineal y análisis numérico.
\parencite{chapra2015}

Un sistema de ecuaciones consiste en un conjunto de ecuaciones que comparten las mismas variables. Resolverlo implica encontrar los valores que satisfacen todas las ecuaciones simultáneamente. Estos sistemas pueden clasificarse en lineales y no lineales, y sus métodos de resolución varían desde técnicas algebraicas clásicas (como la sustitución o igualación) hasta procedimientos numéricos avanzados (como el método de Gauss-Seidel o Newton-Raphson).
\parencite{chapra2015}

En el contexto de la programación numérica, las restricciones se representan y manipulan mediante código, permitiendo no solo resolver el sistema de ecuaciones sino también visualizar gráficamente la región factible y el punto óptimo. Esta representación es especialmente útil para comprender la interacción entre las ecuaciones y las limitaciones impuestas, facilitando el análisis y la toma de decisiones en problemas aplicados de ingeniería, economía y ciencias computacionales.
\parencite{chapra2015}

\section{Ejemplo 1}

Un desarrollador tiene 15 horas semanales para dedicar al desarrollo de software de front-end (x) y back-end (y). Además:

\begin{itemize}
	\item Debe dedicar al menos 5 horas al desarrollo de front-end para cumplir con los entregables del cliente.
	\item El tiempo total no puede exceder 15 horas por restricciones de tiempo del sprint.
\end{itemize}

Formule las restricciones, represéntelas gráficamente e identifique las combinaciones posibles de tiempo a invertir en cada actividad.

\textbf{Variables}

\begin{itemize}
	\item x = horas dedicadas al front-end
	\item y = horas dedicadas al back-end
\end{itemize}

\textbf{Restricciones}

\begin{enumerate}
	\item Debe dedicar al menos 5 horas al mes.
	\begin{itemize}
		\item $x \geq 5$
	\end{itemize}
	\item El tiempo total no puede exceder a 15 horas.
	\begin{itemize}
		\item $x + y \leq 15 $
	\end{itemize}
\end{enumerate}

\textbf{Gráfico generado con python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio1.png}
	\caption{Aplicación de restricciones 1 en Python}
	\label{EjemploRestriccion}
\end{figure}

\textbf{Interpretación del gráfico}

En la representación gráfica se observa la región factible determinada por las restricciones planteadas:

\begin{itemize}
	\item $x \geq 5$: el desarrollador debe dedicar al menos 5 horas al front-end. Esta condición aparece como una línea vertical en $x=5$ y la región válida se encuentra a la derecha de ella.
	\item $y \geq 0$: el tiempo dedicado al back-end no puede ser negativo, por lo que la región se limita a la parte superior del eje $x$.
	\item $x + y \leq 15$: la suma de horas asignadas a front-end y back-end no puede superar las 15 horas semanales. Gráficamente, corresponde a la semirrecta bajo la línea $x+y=15$.
\end{itemize}

La intersección de estas tres restricciones genera una región triangular factible delimitada por los puntos $(5,0)$, $(15,0)$ y $(5,10)$. Esto significa que cualquier combinación de horas ubicada dentro o sobre este triángulo cumple con las condiciones del problema. Por ejemplo, el desarrollador podría dedicar:

\begin{itemize}
	\item 5 horas a front-end y 10 horas a back-end,
	\item 10 horas a front-end y 5 horas a back-end,
	\item o bien 15 horas únicamente a front-end.
\end{itemize}

En conclusión, la región sombreada representa todas las combinaciones posibles de tiempo de trabajo entre front-end y back-end que respetan tanto el mínimo requerido en front-end como la restricción máxima de 15 horas semanales.

\textbf{Código en Python}

\begin{pythoncode}
# Función para preparar expresiones lineales
def preparar_expresion(expr: str) -> str:
expr = expr.replace(" ", "")          # quitar espacios
expr = expr.replace("^", "**")        # potencia
expr = expr.replace("-x", "-1*x")     # caso -x
expr = expr.replace("+x", "+1*x")     # caso +x
if expr.startswith("x"):              # si empieza con x
expr = "1*" + expr
expr = expr.replace("x", "*x")        # poner multiplicación
expr = expr.replace("**x", "*x")      # corregir si se duplicó
return expr

# Restricciones:
# 1) x = 5  (vertical)
# 2) x + y = 15  ->  y = -x + 15
func2 = preparar_expresion("-x+15")

# Rango de la gráfica
xmin, xmax = -5, 20
ymin, ymax = -5, 20

# Recorremos el plano
for y in range(ymax, ymin - 1, -1):
linea = ""
for x in range(xmin, xmax + 1):
# Recta 1: x = 5
cond1 = (x == 5)

# Recta 2: y = -x + 15
try:
y2 = eval(func2)
except:
y2 = None
cond2 = (y2 is not None and abs(y - y2) < 0.5)

# Región factible: x>=5, y>=0, x+y<=15
region = (x >= 5 and y >= 0 and x + y <= 15)

# Qué dibujar
if cond1 and cond2:
linea += "#"
elif cond1:
linea += "*"
elif cond2:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
elif region:
linea += "."
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = x = 5")
print("  o = x + y = 15")
print("  # = Intersección")
print("  . = Región factible")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\section{Ejemplo 2}

Un ingeniero de datos administra dos tipos de servidores en la nube: Servidores A y Servidores B. El costo por hora de Servidor A es S/3 y de Servidor B es S/5. El presupuesto máximo semanal asignado para mantener los servidores es de S/20. Determine cúantas horas puede mantener activos cada tipo de servidor, formule el sistema de ecuaciones y represéntelo gráficamente.

\textbf{Variables}

\begin{itemize}
	\item x = horas de uso de Servidor A
	\item y = horas de uso de Servidor B
\end{itemize}

\textbf{Restricción}

\begin{enumerate}
	\item Se sabe que la hora de Servidor A cuesta S/3, cada hora de Servidor B cuesta S/5 y el presupuesto máximo es S/20.
	\begin{itemize}
		\item $3x + 5y \leq 20$
	\end{itemize}
\end{enumerate}

\textbf{Sistema de ecuaciones lineales}

\[
\begin{cases}
	3x + 5y \leq 20 \\
	x \geq 0 \\
	y \geq 0
\end{cases}
\]

\textbf{Gráfico generado en Python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio2.png}
	\caption{Aplicación de restricciones 2 en Python}
	\label{EjemploRestriccion2}
\end{figure}

\textbf{Interpretación del gráfico}

La recta límite está dada por $3x + 5y = 20$. 
Al interceptar con los ejes coordenados se obtiene que, si $x=0$, entonces $y=4$, 
y si $y=0$, entonces $x=\tfrac{20}{3} \approx 6.67$. 

La región factible corresponde al triángulo delimitado por los puntos $(0,0)$, $(6.67,0)$ y $(0,4)$. 
Cualquier combinación de horas $(x,y)$ dentro de esta región satisface las condiciones de costo máximo. 

En conclusión, el ingeniero de datos puede asignar:

\begin{itemize}
	\item hasta 6 horas con 40 minutos únicamente a servidores A,
	\item hasta 4 horas únicamente a servidores B,
	\item o bien cualquier combinación intermedia que cumpla con el presupuesto, 
	como por ejemplo $(x=2, y=2)$ o $(x=3, y=1)$.
\end{itemize}

\textbf{Código en Python}

\begin{pythoncode}
# Restricción principal: 3x + 5y <= 20  →  y <= (20 - 3x)/5
func = "(20 - 3*x)/5"

# Definimos el rango del gráfico (valores de X y Y)
xmin, xmax = -1, 10     # un poco más para ver bien
ymin, ymax = -1, 6

# Recorremos los valores de Y de arriba hacia abajo
for y in range(ymax, ymin - 1, -1):
linea = ""

for x in range(xmin, xmax + 1):
try:
y_line = eval(func)
except:
y_line = None

# Condición para la recta
cond_line = (y_line is not None and abs(y - y_line) < 0.5)

# Condición para la región factible: debajo de la recta y en el primer cuadrante
cond_region = (y_line is not None and y <= y_line and x >= 0 and y >= 0)

if cond_line:
linea += "*"
elif cond_region:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = Recta 3x + 5y = 20 (frontera)")
print("  o = Región factible (3x + 5y <= 20, x>=0, y>=0)")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\section{Ejemplo 3}

Un administrador de proyectos tecnológicos organiza su tiempo entre reuniones con stakeholders (x) y trabajo en la documentación técnica (y). Las reuniones requieren al menos 4 horas semanales y la documentación al menos 6 horas. Si dispone de 12 horas para ambas actividades, determine la región factible y analice las combinaciones posibles de tiempo.

\textbf{Variables}

\begin{itemize}
	\item x = horas dedicadas a reuniones con stakeholders
	\item y = horas dedicadas a la documentación técnica
\end{itemize}

\textbf{Condiciones}

\begin{enumerate}
	\item Reuniones de al menos 4 horas
	\begin{itemize}
		\item $x \geq 4$
	\end{itemize}
	\item Documentación de al menos 6 horas
	\begin{itemize}
		\item $y \geq 6$
	\end{itemize}
	\item Tiempo total disponible máximo de 12 horas
	\begin{itemize}
		\item $x + y \leq 12$
	\end{itemize}
\end{enumerate}

\textbf{Sistema de ecuaciones lineales}

\[
\begin{cases}
	x \geq 4 \\
	y \geq 6 \\
	x + y \leq 12
\end{cases}
\]

\textbf{Gráfico generado en Python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio3.png}
	\caption{Aplicación de restricciones 3 en Python}
	\label{EjemploRestriccion3}
\end{figure}

\textbf{Interpretación del gráfico}

La recta límite es $x + y = 12$, que corta los ejes en los puntos $(12,0)$ y $(0,12)$. 
Aplicando las condiciones $x \geq 4$ y $y \geq 6$, la región factible se reduce al triángulo formado por los puntos:
\[
(4,6), \quad (4,8), \quad (6,6).
\]

Esto significa que el administrador debe dedicar al menos 4 horas a reuniones y 6 horas a documentación, 
pero no más de 12 horas en total. 

En consecuencia, puede combinar su tiempo de distintas formas dentro de ese triángulo, por ejemplo:

\begin{itemize}
	\item $(x=4, y=7)$: 4 horas de reuniones y 7 de documentación.
	\item $(x=5, y=6)$: 5 horas de reuniones y 6 de documentación.
	\item $(x=6, y=6)$: combinación en el límite máximo permitido.
\end{itemize}

\textbf{Código en Python}

\begin{pythoncode}
# Graficar restricciones del problema 3 en ASCII con sombreado de la región factible

xmin, xmax = 0, 14
ymin, ymax = 0, 14

for y in range(ymax, ymin - 1, -1):
linea = ""
for x in range(xmin, xmax + 1):

# Restricciones
cond_recta = (abs(x + y - 12) < 0.5)   # frontera x+y=12
cond_x = (x == 4)                      # frontera x=4
cond_y = (y == 6)                      # frontera y=6

# Región factible: x>=4, y>=6, x+y<=12
cond_region = (x >= 4 and y >= 6 and (x + y <= 12))

# Puntos de intersección (vértices)
vertices = [(4,6), (4,8), (6,6)]
cond_vertice = (x,y) in vertices

# Dibujar con prioridad
if cond_vertice:
linea += "#"
elif cond_region:
linea += "o"
elif cond_recta:
linea += "*"
elif cond_x:
linea += "|"
elif cond_y:
linea += "="
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
else:
linea += " "
print(linea)

print("\nLeyenda:")
print("  * = Frontera x+y=12")
print("  | = Frontera x=4")
print("  = = Frontera y=6")
print("  # = Vértices de la región factible")
print("  o = Región factible (sombreada)")
print("  + = Origen")
print("  - , | = Ejes coordenados")
\end{pythoncode}

\section{Ejemplo 4}

Una empresa de desarrollo de videojuegos produce dos tipos de assets: Modelos 3D (P1) y Texturas (P2). Cada modelo 3D requiere 2 horas de trabajo y cada textura requiere 3 horas. El equipo de arte tiene un total de 18 horas disponibles semanalmente. Formule las restricciones, represéntelas gráficamente y determine cuántos assets de cada tipo pueden producirse en función del tiempo disponible.

\textbf{Variables}

\begin{itemize}
	\item x = número de modelos 3D (P1)
	\item y = número de texturas (P2)
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item Restricción principal: $2x + 3y \leq 18$
	\item Restricciones adicionales: $x \geq 0, \; y \geq 0$
\end{itemize}

\textbf{Gráfico generado con Python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio4.png}
	\caption{Aplicación de restricciones 4 en Python}
	\label{EjemploRestriccion4}
\end{figure}

\textbf{Interpretación del gráfico}

La frontera de la región factible está dada por la recta $2x + 3y = 18$, que corta al eje $x$ en el punto $(9,0)$ y al eje $y$ en $(0,6)$. 
La región factible corresponde al triángulo con vértices $(0,0)$, $(9,0)$ y $(0,6)$.

El equipo puede producir hasta 9 modelos 3D si dedica todo el tiempo a ellos, o hasta 6 texturas si dedica todo a ese tipo de asset. 
También puede realizar combinaciones intermedias, siempre que se cumpla $2x + 3y \leq 18$. 
Por ejemplo, 3 modelos y 4 texturas consumen exactamente las 18 horas disponibles, mientras que 5 modelos y 2 texturas consumen 16 horas, quedando dentro de la región factible.

\textbf{Código en Python}

\begin{pythoncode}
# Problema 4 - Modelos 3D y Texturas

# Definimos el rango del gráfico
xmin, xmax = -1, 12
ymin, ymax = -1, 8

# Recorremos los valores de Y de arriba hacia abajo
for y in range(ymax, ymin - 1, -1):
linea = ""

for x in range(xmin, xmax + 1):

# Ecuación de la frontera: 2x + 3y = 18
y_line = (18 - 2*x) / 3 if (18 - 2*x) >= 0 else None

# Condición para estar en la recta
cond_line = (y_line is not None and abs(y - y_line) < 0.5)

# Condición para estar en la región factible
cond_region = (x >= 0 and y >= 0 and (2*x + 3*y <= 18))

if cond_line:
linea += "*"
elif cond_region:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = Frontera 2x + 3y = 18")
print("  o = Región factible (2x + 3y <= 18, x>=0, y>=0)")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\section{Ejemplo 5}

Una startup de hardware dispobe de un máximo de 50 unidades de componentes electrónicos. Para ensamblar un dispositivo tipo A se necesitan 5 unidades y para un dispotivo tipo B se necesitan 10 unidades. Determine cuántos dispositivos de cada tipo puede ensamblar sin exceder las 50 unidades de componentes. Formule el problema, resuélalo gráficamnete y explique las posibles combinaciones de producción.

\textbf{Variables}

\begin{itemize}
	\item x = número de dispositivos tipo A
	\item y = número de dispositivos tipo B
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item Restricción principal: $5x + 10y \leq 50$
	\item Restricciones adicionales: $x \geq 0, \; y \geq 0$
\end{itemize}

\textbf{Gráfico generado con Python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio5.png}
	\caption{Aplicación de restricciones 5 en Python}
	\label{EjemploRestriccion5}
\end{figure}

\textbf{Interpretación}

La frontera de la región factible está dada por la recta $5x + 10y = 50$, equivalente a $x + 2y = 10$. 
Esta recta corta al eje $x$ en el punto $(10,0)$ y al eje $y$ en $(0,5)$. 
La región factible corresponde al triángulo con vértices $(0,0)$, $(10,0)$ y $(0,5)$.

La empresa puede ensamblar hasta 10 dispositivos tipo A si dedica todos los componentes a ellos, o hasta 5 dispositivos tipo B si dedica todos los componentes a ese tipo. 
También puede realizar combinaciones intermedias, siempre que se cumpla $5x + 10y \leq 50$. 
Por ejemplo, 6 dispositivos tipo A y 2 tipo B utilizan exactamente las 50 unidades, al igual que 4 dispositivos tipo A y 3 tipo B.

\textbf{Código en Python}

\begin{pythoncode}
# Problema 5 - Dispositivos A y B

# Definimos el rango del gráfico
xmin, xmax = -1, 12
ymin, ymax = -1, 7

# Recorremos los valores de Y de arriba hacia abajo
for y in range(ymax, ymin - 1, -1):
linea = ""

for x in range(xmin, xmax + 1):

# Recta de frontera: x + 2y = 10 -> y = (10 - x)/2
y_line = (10 - x) / 2 if (10 - x) >= 0 else None

# Condición para estar en la recta
cond_line = (y_line is not None and abs(y - y_line) < 0.5)

# Condición para estar en la región factible
cond_region = (x >= 0 and y >= 0 and (x + 2*y <= 10))

if cond_line:
linea += "*"
elif cond_region:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = Frontera (x + 2y = 10)")
print("  o = Región factible (x + 2y <= 10, x>=0, y>=0)")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\chapter{Método de Newton-Raphson}

El \textbf{método de Newton-Raphson} es una técnica iterativa utilizada para encontrar raíces de ecuaciones no lineales de la forma:
\[
f(x) = 0
\]
Es uno de los métodos más eficaces y ampliamente utilizados debido a su rapidez de convergencia cuando se cumplen las condiciones necesarias. Fue propuesto originalmente por Isaac Newton y posteriormente generalizado por Joseph Raphson \parencite{chapra2015}

\section{Fundamento teórico}

La idea básica del método consiste en aproximar la función $f(x)$ mediante su expansión de Taylor alrededor de un punto $x_i$ y despreciar los términos de orden superior:
\[
f(x) \approx f(x_i) + f'(x_i)(x - x_i)
\]

Para hallar la raíz, se hace $f(x) = 0$, y despejando $x$ se obtiene la fórmula iterativa:
\[
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
\]

Esta expresión permite calcular una mejor aproximación de la raíz en cada iteración. El proceso continúa hasta que el valor de $x_{i+1}$ converge a la raíz real con una tolerancia previamente establecida \parencite{chapra2015}

\section{Condiciones de convergencia}

El método de Newton-Raphson presenta convergencia cuadrática, es decir, el error disminuye aproximadamente al cuadrado en cada iteración, siempre que se cumplan las siguientes condiciones \parencite{sullivan2004}:

\begin{itemize}
	\item La función $f(x)$ es continua y derivable en un intervalo que contiene la raíz buscada.
	\item La derivada $f'(x)$ no se anula en el entorno de la raíz.
	\item La estimación inicial $x_0$ está suficientemente cerca de la raíz real.
\end{itemize}

Sin embargo, si $f'(x_i)$ se aproxima a cero o si la estimación inicial está muy alejada, el método puede divergir o generar oscilaciones \parencite{burden2016}.

\section{Criterio de parada}

El proceso iterativo se detiene cuando se cumple alguna de las siguientes condiciones \parencite{chapra2015}:

\begin{itemize}
	\item $|f(x_{i+1})| < \varepsilon$
	\item $|x_{i+1} - x_i| < \varepsilon$
\end{itemize}

donde $\varepsilon$ es la \textit{tolerancia} o el error máximo permitido.

\section{Algoritmo del método de Newton-Raphson}

\begin{tcolorbox}
	\begin{enumerate}
		\item Elegir una estimación inicial $x_0$.
		\item Calcular $f(x_0)$ y $f'(x_0)$.
		\item Evaluar:
		\[
		x_{1} = x_0 - \frac{f(x_0)}{f'(x_0)}
		\]
		\item Repetir el proceso:
		\[
		x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
		\]
		hasta que se cumpla el criterio de convergencia.
	\end{enumerate}
\end{tcolorbox}

\section{Aplicación del método en Python}

El objetivo fue desarrollar en el lenguaje de programación Python un programa que permita al usuario ingresar una función $f(x)$ y graficarla en un intervalo definido. Esta etapa inicial tiene como propósito ayudar al usuario a identificar visualmente las posibles raíces y decidir si desea aplicar el método de Newton-Raphson.

En caso afirmativo, el programa solicita un valor inicial $x_1$ basado en la observación de la gráfica y ejecuta el algoritmo iterativo de Newton-Raphson hasta que la diferencia entre dos aproximaciones sucesivas sea menor a una tolerancia predefinida. Finalmente, el programa muestra en pantalla la raíz aproximada encontrada y el número de iteraciones necesarias para alcanzarla.

Este enfoque combina la interpretación gráfica con el análisis numérico, promoviendo una comprensión más completa del comportamiento de la función y de la eficacia del método iterativo.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para evaluar si realizar o no el método.
	\item La raíz encontrada.
	\item Número de iteraciones realizadas hasta encontrar la raíz.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función y su derivada (usando derivada numérica)
def f(x):
return eval(func_str)

def f_prime(x, h=1e-6):  # derivada numérica
return (f(x + h) - f(x - h)) / (2 * h)

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar Newton-Raphson ===
op = input("¿Desea encontrar una raíz con el método de Newton-Raphson? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de punto inicial ===
x0 = float(input("Basado en la gráfica, ingrese el valor inicial x1: "))

# Parámetros del método
tol = 1e-6
max_iter = 100

# Iteraciones
for i in range(1, max_iter + 1):
fx = f(x0)
fpx = f_prime(x0)

if fpx == 0:
print(f"La derivada es cero en x = {x0}. El método no puede continuar.")
break

x1 = x0 - fx / fpx

# Verificar convergencia
if abs(x1 - x0) < tol:
print(f"\n✅ Raíz aproximada encontrada: {x1:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0 = x1
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")

else:
print("No se aplicó el método de Newton-Raphson.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon2.png}
	\caption{Método de Newthon-Rapshon en Python}
	\label{Newthon-R}
\end{figure}

\chapter{Método de Bisección}

El método de bisección es uno de los algoritmos más simples, robustos y confiables para la localización de raíces de ecuaciones no lineales de la forma
\[
f(x)=0.
\]
Su fundamento teórico se basa en el \textbf{Teorema del Valor Intermedio}, el cual garantiza la existencia de una raíz siempre que la función sea continua en un intervalo cerrado $[a,b]$ y que se cumpla la condición
\[
f(a)\, f(b) < 0.
\]
Esto indica que en el intervalo ocurre un cambio de signo y, por tanto, debe existir al menos una raíz en su interior \parencite{burden2016}.

\section{Idea fundamental del método}

El método consiste en dividir sucesivamente el intervalo $[a,b]$ por su punto medio. Si llamamos
\[
c = \frac{a+b}{2},
\]
entonces evaluamos $f(c)$ y determinamos en qué subintervalo persiste el cambio de signo:

\begin{itemize}
	\item Si $f(a)\, f(c) < 0$, la raíz se encuentra en $[a,c]$.
	\item Si $f(c)\, f(b) < 0$, la raíz se encuentra en $[c,b]$.
\end{itemize}

Este proceso se repite recursivamente, produciendo intervalos cada vez más pequeños. Debido a su naturaleza, el método \textbf{siempre converge} cuando la función es continua y se inicia con un intervalo válido, aunque la convergencia es relativamente lenta \parencite{chapra2015}.

\section{Criterios de parada}

El método se detiene cuando se cumple alguna de las siguientes condiciones:

\begin{enumerate}
	\item El ancho del intervalo es menor que una tolerancia establecida:
	\[
	|b-a| < \varepsilon.
	\]
	\item El valor funcional es cercano a cero:
	\[
	|f(c)| < \delta.
	\]
	\item Se alcanza un número máximo de iteraciones:
	\[
	n \ge n_{\max}.
	\]
\end{enumerate}

El error después de $n$ iteraciones está acotado por
\[
|x - c_n| \le \frac{b-a}{2^n},
\]
lo cual permite estimar de manera precisa el número de pasos necesarios para obtener una tolerancia deseada \parencite{suli2003}.

\section{Ventajas del método}

El método de bisección posee varias ventajas importantes:

\begin{itemize}
	\item Garantiza convergencia siempre que exista un cambio de signo en el intervalo.
	\item Es simple de implementar.
	\item Permite una estimación directa del error en cada iteración.
	\item Es estable numéricamente y no requiere derivadas.
\end{itemize}

Estas características lo convierten en un método ideal para iniciar procesos de localización de raíces o para validar aproximaciones obtenidas mediante métodos más rápidos pero menos robustos, como Newton-Raphson o la secante \parencite{press2007}.

\section{Desventajas}

A pesar de su robustez, el método de bisección presenta algunas limitaciones:

\begin{itemize}
	\item La convergencia es lineal y relativamente lenta en comparación con otros métodos.
	\item Requiere conocer un intervalo donde la función cambie de signo.
	\item No obtiene raíces múltiples o raíces donde la función no cambia de signo.
\end{itemize}

Aun así, su combinación de simplicidad y fiabilidad lo convierte en un método fundamental dentro de los algoritmos de análisis numérico \parencite{burden2016}.

\section{Aplicación del método en Python}

Se desarrolló en Python un programa que permite al usuario ingresar una función matemática y visualizar su gráfico en un intervalo definido. Esta etapa inicial facilita la elección del intervalo $[a,b]$ donde la función cambia de signo.

Una vez seleccionado el intervalo, el programa ejecuta el método de bisección iterativamente, mostrando en pantalla una tabla con los valores de $a$, $b$, $c$, $f(c)$ y el error de cada iteración. El proceso finaliza cuando se cumple la condición de tolerancia o se alcanza el número máximo de iteraciones. Finalmente, se presenta la raíz aproximada encontrada.

Este enfoque combina el análisis gráfico con la interpretación numérica, permitiendo comprender mejor el comportamiento de la función y la estabilidad del método.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para evaluar el intervalo de búsqueda.
	\item Tabla con las iteraciones del método.
	\item Raíz aproximada y número de iteraciones realizadas.
\end{itemize}

\textbf{Restricciones}

El método requiere que:
\begin{itemize}
	\item $f(x)$ sea continua en el intervalo $[a,b]$.
	\item Se cumpla la condición $f(a)\cdot f(b) < 0$.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función
def f(x):
return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de Bisección ===
op = input("¿Desea encontrar una raíz con el método de Bisección? (s/n): ").lower()

if op == "s":
# === 4. Ingreso del intervalo inicial ===
a = float(input("Ingrese el extremo izquierdo del intervalo (a): "))
b = float(input("Ingrese el extremo derecho del intervalo (b): "))

# Verificación del cambio de signo
if f(a) * f(b) > 0:
print("\n⚠️ No hay cambio de signo en el intervalo [a, b]. Intente con otro intervalo.")
else:
# Parámetros del método
tol = 1e-6
max_iter = 100

print("\nIteración |     a       |      b       |      c       |    f(c)     |   Error")
print("----------------------------------------------------------------")

for i in range(1, max_iter + 1):
c = (a + b) / 2
fc = f(c)
error = abs(b - a) / 2

print(f"{i:9d} | {a:10.6f} | {b:10.6f} | {c:10.6f} | {fc:10.6f} | {error:10.6f}")

if abs(fc) < tol or error < tol:
print(f"\n✅ Raíz aproximada encontrada: {c:.6f}")
print(f"Iteraciones realizadas: {i}")
break

if f(a) * fc < 0:
b = c
else:
a = c
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de Bisección.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Biseccion1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Biseccion2.png}
	\caption{Método de Bisección en Python}
	\label{Biseccion}
\end{figure}

\chapter{Método de la Secante}

El método de la secante es una técnica numérica ampliamente utilizada para la resolución de ecuaciones no lineales, especialmente en contextos donde la derivada de la función no está disponible o resulta difícil de calcular. A diferencia del método de Newton–Raphson, que requiere la evaluación explícita de la derivada, la secante se basa en una aproximación numérica de la misma utilizando dos puntos consecutivos de la función \parencite{burden2011,chapra2015}. 

\section{Fundamento teórico}

El método surge de la idea de aproximar la derivada de la función mediante un cociente incremental, reemplazando la derivada verdadera por:

\[
f'(x_n) \approx \frac{f(x_n)-f(x_{n-1})}{x_n - x_{n-1}}.
\]

Sustituyendo esta expresión en la fórmula de Newton--Raphson se obtiene la iteración del método de la secante:

\[
x_{n+1} = x_n - f(x_n)\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.
\]

La deducción formal y el análisis matemático del método pueden consultarse en textos clásicos de análisis numérico \parencite{burden2011}, así como en manuales modernos de métodos computacionales \parencite{chapra2015,atkinson2009}.

\section{Interpretación geométrica}

Geométricamente, el método consiste en trazar la recta secante que pasa por los puntos \((x_{n-1}, f(x_{n-1}))\) y \((x_n, f(x_n))\), y encontrar su intersección con el eje \(x\). Esta construcción geométrica proporciona una aproximación sucesiva a la raíz de la ecuación \(f(x)=0\) \parencite{sullivan2004}.

La secante generada en cada iteración reemplaza el uso de la tangente del método de Newton, permitiendo que el método avance sin necesidad de calcular derivadas. Esta propiedad convierte a la secante en un algoritmo eficiente en problemas aplicados donde la evaluación de \(f'(x)\) puede ser costosa o inestable \parencite{cheney2009}.

\section{Convergencia}

El método posee una convergencia superlineal, cuya razón de convergencia es aproximadamente \(1.618\), el número áureo. Aunque es menos rápido que Newton–Raphson, suele ser más eficiente cuando la derivada no está disponible o cuando su cálculo es propenso a errores numéricos \parencite{atkinson2009}. Sin embargo, su éxito requiere seleccionar dos valores iniciales adecuados para evitar divisiones entre valores de función muy pequeños o iteraciones divergentes \parencite{burden2011}.

\section{Ventajas y limitaciones}

Entre sus principales ventajas destacan:

\begin{itemize}
	\item No requiere el cálculo de la derivada de la función.
	\item Tiende a ser más estable que Newton–Raphson cuando la derivada es difícil de evaluar.
	\item Posee una tasa de convergencia superior al método de bisección.
\end{itemize}

Sus principales limitaciones incluyen:

\begin{itemize}
	\item No garantiza convergencia global.
	\item Requiere dos valores iniciales definidos.
	\item Puede divergir si los valores iniciales no son adecuados o si la función presenta discontinuidades o múltiples raíces cercanas.
\end{itemize}

Para un análisis detallado de sus propiedades teóricas y aplicaciones prácticas pueden consultarse referencias especializadas en análisis numérico \parencite{burden2011,chapra2015,atkinson2009,cheney2009}.

\section{Aplicación del método en Python}

Se desarrolló un programa en Python que permite al usuario ingresar una función $f(x)$ y graficarla en un intervalo definido. Esta etapa inicial facilita la identificación visual de posibles raíces y la selección de los valores iniciales $x_0$ y $x_1$.

Luego, el programa aplica el método de la secante iterativamente hasta alcanzar una tolerancia establecida o un número máximo de iteraciones. En cada iteración, se muestran los valores de $x_0$, $x_1$, $f(x_0)$, $f(x_1)$, la nueva aproximación $x_2$ y el error absoluto. Finalmente, se imprime la raíz aproximada encontrada y el número de iteraciones necesarias.

Este procedimiento combina la exploración gráfica con el razonamiento numérico, fomentando una comprensión más completa de la convergencia y del comportamiento de la función.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para visualizar la función y elegir los puntos iniciales.
	\item Tabla con los valores de cada iteración.
	\item Raíz aproximada y número de iteraciones necesarias.
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item $f(x)$ debe ser continua en el intervalo analizado.
	\item Los valores iniciales $x_0$ y $x_1$ deben ser distintos y cercanos a la raíz.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función
def f(x):
return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de la secante ===
op = input("¿Desea encontrar una raíz con el método de la Secante? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de puntos iniciales ===
x0 = float(input("Ingrese el primer valor inicial x0: "))
x1 = float(input("Ingrese el segundo valor inicial x1: "))

# Parámetros del método
tol = 1e-6
max_iter = 100

print("\nIteración |     x0      |      x1      |     f(x0)     |     f(x1)     |     x2      |   Error")
print("----------------------------------------------------------------------")

for i in range(1, max_iter + 1):
f0 = f(x0)
f1 = f(x1)

if f1 - f0 == 0:
print(f"\n⚠️ División por cero en la iteración {i}. El método no puede continuar.")
break

x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
error = abs(x2 - x1)

print(f"{i:9d} | {x0:10.6f} | {x1:10.6f} | {f0:12.6f} | {f1:12.6f} | {x2:10.6f} | {error:10.6f}")

if error < tol:
print(f"\n✅ Raíz aproximada encontrada: {x2:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0, x1 = x1, x2

else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de la Secante.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Secante1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Secante2.png}
	\caption{Método de la Secante en Python}
	\label{Secante}
\end{figure}

\chapter{Método de Punto Fijo}

El método de punto fijo es uno de los procedimientos fundamentales para resolver ecuaciones no lineales de la forma
\[
f(x) = 0.
\]
A diferencia de otros métodos basados directamente en la función $f(x)$, el método de punto fijo se construye a partir de una transformación adecuada de la ecuación original en una función equivalente
\[
x = g(x),
\]
de modo que la raíz buscada es un \textbf{punto fijo} de la función $g$, es decir, un valor $r$ tal que $g(r) = r$ \parencite{burden2016}. 

La ecuación original puede expresarse de diversas maneras para obtener distintas funciones de iteración $g(x)$. La elección de esta función es crucial para garantizar la convergencia y determinar la eficiencia del método.

\section{Definición y formulación básica}

Dado un valor inicial $x_0$, la aproximación iterativa se construye mediante el proceso repetitivo:
\[
x_{n+1} = g(x_n), \qquad n = 0,1,2,\ldots
\]
Si esta sucesión converge a un valor $r$, entonces
\[
\lim_{n \to \infty} x_{n} = r \quad \Rightarrow \quad r = g(r),
\]
lo que confirma que $r$ es un punto fijo de $g$ y, por ende, una solución de la ecuación original \parencite{chapra2015}.

\section{Condición de convergencia}

El comportamiento del método depende de las propiedades de la función $g(x)$. Uno de los resultados más importantes para garantizar convergencia es el siguiente:

\textbf{Criterio de convergencia.}
Supongamos que la función $g$ es continua en un intervalo $I$ y que además su derivada $g'(x)$ es continua en el mismo intervalo. Si existe una constante $0 < k < 1$ tal que
\[
|g'(x)| \le k \qquad \text{para todo } x \in I,
\]
entonces el método de punto fijo es convergente para cualquier elección de $x_0 \in I$, y la sucesión generada converge a un único punto fijo en dicho intervalo \parencite{burden2011}.

Este criterio implica que la derivada de $g$ controla la “fuerza” con la que la iteración se acerca al punto fijo. En términos prácticos:

\[
|g'(r)| < 1 \quad \Rightarrow \quad \text{convergencia local},
\]
\[
|g'(r)| > 1 \quad \Rightarrow \quad \text{divergencia}.
\]

Esto hace evidente que la elección de la forma $g(x)$ no es arbitraria. Algunas transformaciones del tipo $x = g(x)$ producen convergencia, otras generan oscilaciones y otras divergencia total \parencite{cheney2009}.

\section{Orden de convergencia}

El método de punto fijo tiene convergencia lineal bajo las condiciones mencionadas. Esto significa que existe una constante $C$ tal que
\[
|x_{n+1} - r| \approx C\, |x_n - r|,
\]
lo cual sugiere una velocidad de aproximación más lenta frente a métodos como Newton-Raphson, cuya convergencia es cuadrática \parencite{atkinson2009}. Sin embargo, su simplicidad lo convierte en una herramienta útil para la enseñanza y para establecer intervalos iniciales seguros para otros métodos más rápidos.

\section{Errores y criterios de parada}

El error en la iteración puede estimarse mediante:
\[
|x_{n+1} - x_n| < \varepsilon \quad \text{o bien} \quad |g(x_n) - x_n| < \varepsilon,
\]
donde $\varepsilon$ es una tolerancia escogida. Otra forma consiste en fijar un número máximo de iteraciones si la función converge lentamente o presenta oscilaciones \parencite{press2007}.

\section{Ventajas del método}

El método de punto fijo presenta varias virtudes importantes:

\begin{itemize}
	\item Su implementación es extremadamente sencilla.
	\item No requiere derivadas como Newton-Raphson.
	\item Es útil para analizar transformaciones funcionales equivalentes.
	\item Proporciona un marco general para estudiar muchos métodos iterativos.
	\item Permite visualizar la convergencia mediante diagramas cobweb (trampas de telaraña), muy utilizados en la enseñanza \parencite{anton2012}.
\end{itemize}

Además, su estructura simple hace posible analizar la estabilidad de los puntos fijos en modelos matemáticos aplicados, como ecuaciones diferenciales, sistemas dinámicos y procesos iterativos en ingeniería \parencite{suli2003}.

\section{Desventajas}

A pesar de su utilidad conceptual y didáctica, el método presenta ciertas limitaciones:

\begin{itemize}
	\item La convergencia depende fuertemente de la elección de $g(x)$.
	\item Incluso con una buena elección, la convergencia es lineal, por lo que puede ser lenta.
	\item Si $|g'(x)| \ge 1$, la iteración diverge.
	\item No siempre es sencillo encontrar una transformación apropiada.
\end{itemize}

En aplicaciones industriales o científicas, suele preferirse utilizar punto fijo como método preliminar para garantizar la existencia de una raíz antes de usar algoritmos más robustos o rápidos, como Newton-Raphson, la secante o métodos híbridos \parencite{chapra2015}.

\section{Interpretación gráfica}

Gráficamente, el método consiste en trazar la curva $y = g(x)$ junto con la recta $y = x$. El punto donde ambas se intersectan es el punto fijo. La iteración sigue los pasos:

\begin{enumerate}
	\item Comenzar en $(x_0, g(x_0))$.
	\item Proyectar verticalmente hacia la curva.
	\item Proyectar horizontalmente hacia la recta $y=x$.
\end{enumerate}

Este proceso se repite hasta alcanzar una convergencia visual. Este tipo de representación, conocida como \textit{diagrama cobweb}, es muy útil para estudiar estabilidad y para reforzar la intuición del método \parencite{riley2006}.

\section{Conclusión}

El método de punto fijo constituye una herramienta esencial en el análisis numérico. Aunque no es el método más rápido ni el más eficiente, su simplicidad, su fundamento teórico sólido y su relación con otros métodos iterativos lo hacen indispensable en la formación matemática y en el estudio formal de la convergencia de algoritmos numéricos.

Su aplicación correcta depende de una adecuada elección de la función $g(x)$ y de un análisis cuidadoso de las condiciones de convergencia. Esto permite utilizarlo como punto de partida en el estudio y aplicación de métodos más avanzados para la resolución de ecuaciones no lineales \parencite{burden2016}.

\section{Aplicación del método en Python}

El objetivo fue desarrollar un programa en Python que permita ingresar una función $f(x)$ y su forma iterativa $g(x)$, graficar la función y luego aplicar el método de Punto Fijo si el usuario lo desea.  
El programa calcula sucesivamente los valores de $x_{n+1} = g(x_n)$ hasta alcanzar una precisión deseada y muestra los resultados obtenidos.

\textbf{Entrada}

\begin{itemize}
	\item Una cadena de texto que representa la función original $f(x)$.
	\item La forma iterativa correspondiente $g(x)$.
	\item El intervalo para graficar.
	\item El valor inicial $x_0$.
\end{itemize}

\begin{align*}
	f(x) = \cos(x) - x \\
	g(x) = \cos(x)
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica de la función $f(x)$.
	\item La raíz aproximada encontrada.
	\item Número de iteraciones realizadas hasta cumplir la tolerancia.
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item El método requiere que $|g'(x)| < 1$ en el entorno de la raíz para garantizar la convergencia.
	\item La función debe ser continua y evaluable en todo el intervalo seleccionado.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función y su forma iterativa g(x) ===
print("=== MÉTODO DEL PUNTO FIJO ===")
print("Recuerde que f(x) = 0 se reescribe como x = g(x)")
print("Ejemplo: Si f(x) = cos(x) - x, entonces g(x) = cos(x)\n")

func_str = input("Ingrese la función original f(x): ")   # Ejemplo: np.cos(x) - x
g_str = input("Ingrese la función iterativa g(x): ")     # Ejemplo: np.cos(x)

# Definición de funciones
def f(x):
return eval(func_str, {"np": np, "x": x})

def g(x):
return eval(g_str, {"np": np, "x": x})

# === 2. Graficar la función f(x) ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de punto fijo ===
op = input("¿Desea aplicar el método de Punto Fijo? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de valor inicial ===
x0 = float(input("Ingrese el valor inicial x0: "))

tol = 1e-6
max_iter = 100

print("\nIteración |     x0      |     g(x0)     |     f(x0)     |   Error")
print("---------------------------------------------------------------")

for i in range(1, max_iter + 1):
x1 = g(x0)
error = abs(x1 - x0)

print(f"{i:9d} | {x0:10.6f} | {x1:12.6f} | {f(x1):12.6f} | {error:10.6f}")

if error < tol:
print(f"\n✅ Raíz aproximada encontrada: {x1:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0 = x1
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de Punto Fijo.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Puntof1.png}
	\includegraphics[width=0.60\linewidth]{Figuras/Puntof2.png}
	\includegraphics[width=0.60\linewidth]{Figuras/Puntof3.png}
	\caption{Método de Punto Fijo en Python}
	\label{Puntofijo}
\end{figure}

\chapter{Método de Regula Falsi}

El método de \textit{regula falsi}, también conocido como \textit{método de la falsa posición}, es una técnica clásica para la solución numérica de ecuaciones no lineales de la forma
\[
f(x) = 0.
\]
Este método combina aspectos del método de la bisección y del método de la secante, manteniendo siempre un intervalo que contiene la raíz mientras utiliza una aproximación lineal similar a la secante para generar nuevas aproximaciones. Su origen se remonta a prácticas matemáticas antiguas, pero su formalización moderna aparece descrita en textos fundamentales de análisis numérico \parencite{burden2011, chapra2015, cheney2009}.

\section{Idea fundamental del método}

Sea un intervalo cerrado $[a,b]$ tal que la función $f$ sea continua en él y satisfaga la condición
\[
f(a)\, f(b) < 0,
\]
lo cual garantiza, mediante el Teorema del Valor Intermedio, la existencia de al menos una raíz en dicho intervalo. A diferencia del método de la bisección, que toma el punto medio como nueva aproximación, el método de regula falsi utiliza la recta secante que une los puntos $(a, f(a))$ y $(b, f(b))$ para obtener una aproximación más refinada a la raíz \parencite{burden2016, chapra2015}.

El punto donde esta recta corta al eje $x$ se calcula mediante la fórmula:
\[
x_r = b - \frac{f(b)\,(a - b)}{f(a) - f(b)}.
\]
Este $x_r$ se denomina \textit{falsa posición} y representa la aproximación actual de la raíz.

\section{Actualización del intervalo}

Una vez calculado $x_r$, se evalúa $f(x_r)$ y se conserva el intervalo que garantice el cambio de signo. Es decir:
\[
\begin{cases}
	a = x_r & \text{si } f(a)\, f(x_r) < 0,\\[4pt]
	b = x_r & \text{si } f(a)\, f(x_r) > 0.
\end{cases}
\]

Este proceso asegura que la raíz permanece dentro del intervalo, proporcionando la robustez característica del método de bisección, pero con un paso adicional guiado por la pendiente de la secante, lo que permite avanzar de manera más eficiente en muchas situaciones \parencite{atkinson2009, suli2003}.

\section{Convergencia}

El método de regula falsi es linealmente convergente, aunque en algunos casos su velocidad puede ser lenta. Esto ocurre especialmente cuando uno de los extremos del intervalo permanece fijo durante muchas iteraciones, lo cual puede suceder si la función presenta curvaturas pronunciadas o cambios de pendiente que provocan que la secante tienda a acercarse preferentemente a uno de los extremos \parencite{press2007, burden2011}.

A pesar de ello, su principal ventaja es que **nunca pierde la raíz**, ya que siempre mantiene el intervalo acotado con un cambio de signo, lo que lo hace más seguro que métodos que no usan acotamiento, como el método de la secante clásico.

\section{Criterios de parada}

Los criterios más empleados para finalizar el proceso iterativo son:

\begin{itemize}
	\item \textbf{Error relativo entre iteraciones:}
	\[
	\left| \frac{x_{r}^{(k)} - x_{r}^{(k-1)}}{x_{r}^{(k)}} \right| < \varepsilon.
	\]
	\item \textbf{Evaluación de la función:}
	\[
	|f(x_r)| < \varepsilon.
	\]
	\item \textbf{Máximo número de iteraciones:} Se detiene el proceso cuando se supera un número preestablecido de iteraciones.
\end{itemize}

Estos criterios permiten controlar la precisión deseada y asegurar que la aproximación obtenida es suficientemente cercana a la raíz \parencite{chapra2015, burden2016}.

\section{Ventajas y desventajas}

\textbf{Ventajas:}
\begin{itemize}
	\item Conserva la propiedad de acotamiento del método de la bisección.
	\item Puede converger más rápido que la bisección en muchas funciones.
	\item No requiere cálculo de derivadas.
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
	\item La convergencia puede ser muy lenta si uno de los extremos del intervalo queda ``atrapado''.
	\item Usualmente tiene una convergencia lineal, más lenta que la del método de la secante o Newton-Raphson.
\end{itemize}

\section{Resumen conceptual}

El método de regula falsi representa un compromiso entre estabilidad y velocidad: mantiene la seguridad del acotamiento, pero intenta mejorar la rapidez usando una aproximación lineal. Por ello, es especialmente útil cuando se requiere una garantía estricta de que la raíz no se perderá, pero se desea evitar la lentitud del método de la bisección tradicional \parencite{burden2011, chapra2015, cheney2009}.

\section{Aplicación del método en Python}

El objetivo fue desarrollar un programa en Python que permita al usuario ingresar una función $f(x)$, graficarla en un intervalo definido y aplicar el método de Regula Falsi si así lo desea.  
El programa realiza iteraciones hasta que se cumpla un criterio de tolerancia, mostrando en cada paso los valores de $a$, $b$, $c$, $f(c)$ y el error estimado.

\textbf{Entrada}

\begin{itemize}
	\item Una cadena de texto que representa la función matemática $f(x)$.
	\item Los valores iniciales $a$ y $b$ que delimitan el intervalo de búsqueda.
	\item El intervalo para graficar la función.
\end{itemize}

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica de la función $f(x)$ en el intervalo ingresado.
	\item La raíz aproximada encontrada.
	\item Número de iteraciones realizadas hasta cumplir la tolerancia.
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item La función debe ser continua en el intervalo $[a, b]$.
	\item Debe cumplirse la condición de cambio de signo $f(a)f(b) < 0$.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
print("=== MÉTODO DE REGULA FALSI (FALSA POSICIÓN) ===")
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definición de la función
def f(x):
return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de Regula Falsi ===
op = input("¿Desea aplicar el método de Regula Falsi? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de los extremos del intervalo ===
a = float(input("Ingrese el valor de a (extremo izquierdo): "))
b = float(input("Ingrese el valor de b (extremo derecho): "))

# Comprobación del cambio de signo
if f(a) * f(b) > 0:
print("⚠️ La función no cambia de signo en el intervalo. No se puede aplicar el método.")
else:
tol = 1e-6
max_iter = 100

print("\nIteración |      a      |      b      |      c      |    f(c)     |   Error")
print("--------------------------------------------------------------")

c_old = a
for i in range(1, max_iter + 1):
# Fórmula de Regula Falsi
c = b - (f(b) * (a - b)) / (f(a) - f(b))
error = abs(c - c_old)
c_old = c

print(f"{i:9d} | {a:10.6f} | {b:10.6f} | {c:10.6f} | {f(c):10.6f} | {error:10.6f}")

if abs(f(c)) < tol or error < tol:
print(f"\n✅ Raíz aproximada encontrada: {c:.6f}")
print(f"Iteraciones realizadas: {i}")
break

# Actualización de intervalos
if f(a) * f(c) < 0:
b = c
else:
a = c
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de Regula Falsi.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Regula1.png}
	\includegraphics[width=0.60\linewidth]{Figuras/Regula2.png}
	\caption{Método de Regula Falsi en Python}
	\label{RegulaFalsi}
\end{figure}