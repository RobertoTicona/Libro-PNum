\part{Unidad I}

\chapter{Programación Numérica}

La \textbf{programación numérica} es una disciplina que combina las matemáticas aplicadas y la informática con el objetivo de resolver problemas cuantitativos mediante métodos computacionales. Se centra en el diseño, análisis e implementación de algoritmos que permiten obtener soluciones aproximadas a ecuaciones, sistemas y modelos que, en la mayoría de los casos, no pueden resolverse de forma analítica \parencite{burden2016,chapra2015}.

A diferencia de la programación convencional, que busca desarrollar aplicaciones funcionales o sistemas de información, la programación numérica se orienta a la resolución eficiente y precisa de problemas matemáticos. Entre sus principales aplicaciones se encuentran la simulación de fenómenos físicos y biológicos, la modelización económica, la ingeniería de datos, la inteligencia artificial y el análisis estadístico en ciencias de la salud \parencite{press2007}.

El objetivo fundamental de esta área es transformar problemas continuos en representaciones discretas que puedan ser tratadas por un computador. De esta forma, se logra aproximar soluciones a problemas de optimización, integración, derivación, interpolación, ajuste de curvas y resolución de ecuaciones diferenciales.

En términos prácticos, la programación numérica permite al investigador o profesional:
\begin{itemize}
	\item Resolver ecuaciones no lineales mediante métodos iterativos.
	\item Aproximar derivadas e integrales de funciones cuando no se dispone de una forma analítica.
	\item Interpolar o ajustar funciones a datos experimentales.
	\item Optimizar funciones de una o varias variables bajo restricciones.
	\item Analizar errores y estimar la estabilidad numérica de los métodos empleados.
\end{itemize}

Actualmente, lenguajes como \texttt{Python}, \texttt{R}, \texttt{MATLAB} y \texttt{Julia} ofrecen bibliotecas especializadas que facilitan el desarrollo de algoritmos numéricos de alto rendimiento. Estos entornos han hecho posible que la programación numérica sea una herramienta accesible y poderosa para la investigación científica, la ingeniería y la docencia \parencite{chapra2015}.

En síntesis, la programación numérica constituye una base esencial para la solución computacional de problemas científicos y técnicos, integrando el razonamiento matemático con la capacidad de cómputo moderna.


\chapter{Funciones}

\section{Funciones a nuestro alrededor}

En casi todos los fenómenos físicos observamos que una cantidad depende de otra. Por ejemplo, la estatura de una persona depende de su edad, la temperatura de la fecha, el costo de enviar un paquete por correo depende de su peso. Usamos el término función para describir esta dependencia de una cantidad con respecto a otra. Esto es, decimos lo siguiente: \parencite{stewart2001}

\begin{itemize}
	\item La estatura es una función de la edad.
	\item La temperatura es una función de la fecha.
	\item El costo de enviar un paquete por correo depende de su peso.
\end{itemize}

\section{Definición de función}

\begin{tcolorbox}
	Una \textbf{función} $f$ es una regla que asigna a cada elemento x de un conjunto A exactamente un elemento, llamado $f(x)$, de un conjunto B.
\end{tcolorbox}

Para hablar de una función, es necesario darle un nombre. Usaremos letras como $f, g, h, ...$ para representar funciones. Por ejemplo, podemos usar la letra $f$ para representar una regla como sigue:

\begin{center}
	$"f"$ es la regla "elevar al cuadrado el número"
\end{center}

cuando escribimos $f(2)$ queremos decir "aplicar la regla f al número 2". La aplicación de la regla da $f(2) = 2^2 = 4$. Del mismo modo, $f(3) = 3^2 = 9, f(4) = 4^2 = 16$, y en general $f(x) = x^2$. \parencite{stewart2001}

Por lo general consideramos funciones para las cuales los conjuntos A y B son conjuntos de número reales. El símbolo $f(x)$ se lee "f de x" o "f en x" y se denomina \textbf{valor de $f$ en $x$}, o la \textbf{imagen de $x$ bajo $f$}. El conjunto A recibe el nombre de \textbf{dominio} de la función. El \textbf{rango} de $f$ es el conjunto de todos los valores posibles de $f(x)$ cuando $x$ varía en todo el dominio. El símbolo que representa un número arbitrario del dominio de una función $f$ se llama \textbf{variable independiente}. El símbolo que representa un número en el rango de $f$ se llama \textbf{variable dependiente}. Por tanto, si escribimos $y = f(x)$, entonces $x$ es la variable independiente y $y$ es la variable dependiente. \parencite{stewart2001}

Es útil considerar una función como una \hyperref[Diagramaflechasf]{\textbf{máquina}}. Si $x$ está en el dominio de la función $f$, entonces cuando $x$ entra a la máquina, es aceptada como \textbf{entrada} y la máquina produce una \textbf{salida} $f(x)$ de acuerdo con la regla de la función. Así, podemos considerar el dominio como el conjunto de todas las posibles entradas y el rango como el conjunto de todas las posibles salidas. \parencite{stewart2001}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Diagramaflechasf.png}
	\caption{Diagrama de flechas de $f$}
	\label{Diagramaflechasf}
\end{figure}

\section{Cuatro formas de representar una función}

Para entender mejor lo que es una función, podemos describir una función específica en las siguientes cuatro formas: \parencite{stewart2016}

\begin{itemize}
	\item verbalmente (por descripción en palabras)
	\item algebraicamente (por una fórmula explícita)
	\item visualmente (por una gráfica)
	\item numéricamente (por una tabla de valores)
\end{itemize}

Una función individual puede estar representada en las cuatro formas, y con frecuencia es útil pasar de una representación a otra para adquirir más conocimientos sobre la función. No obstante, ciertas funciones se describen en forma más natural por medio de un método que por los otros. Un ejemplo de una descripción verbal es la siguiente regla para convertir entres escalas de temperatura: \parencite{stewart2016}

\begin{center}
	"Para hallar el equivalente Fahrenheit de una temperatura Celsius, multiplicar por $\dfrac{9}{5}$ la temperatura Celsius y luego sumar 32"
\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/Representacionfunciones.png}
	\caption{Cuatro formas de representar una función}
	\label{Formasfunciones}
\end{figure}

\section{Gráficas de funciones}

\subsection{Gráficas de funciones por localización de puntos}

Para graficar una función $f$ localizamos los puntos $(x,f(x))$ en un plano de coordenadas. En otras palabras, localizamos los puntos $(x,y)$ cuya coordenada $x$ es una entrada y cuya coordenada $y$ es la correspondiente salida de la función. \parencite{stewart2016}

\begin{tcolorbox}
	Si $f$ es una función con dominio A, entonces la \textbf{gráfica} de $f$ es el conjunto de pares ordenados
	\begin{center}
		$(x, f(x)) | x \in A$
	\end{center}
	localizados en un plano de coordendas. En otras palabras, la gráfica de $f$ es el conjunto de todos los puntos $(x,y)$ tales que $y = f(x)$; esto es, la gráfica de f es la gráfica de la ecuación $y = f(x)$.
\end{tcolorbox}

La gráfica de una función $f$ da un retrato del comportamiento o "historia de la vida" de la función. Podemos leer el valor de $f(x)$ a partir de la gráfica como la altura de la gráfica arriba del punto $x$. \parencite{stewart2016}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{Figuras/Alturadegrafica.png}
	\caption{La altura de la gráfica arriba del punto x es el valor de $f(x)$}
	\label{Alturadegrafica}
\end{figure}

Una función $f$ de la forma $f(x) = mx + b$ se denomina \textbf{función lineal} porque su gráfica es la gráfica de la ecuación $y = mx + b$, que representa una recta con pendiente $m$ y punto de intersección $b$ en $y$. Un caso especial de una función lineal se presenta cuando la pendiente es m = 0. La función $f(x) = b$, donde $b$ es un número determinado, recibe el nombre de $función constante$ porque todos sus valores son el mismo número, es decir, $b$. Su gráfica es la recta horizontal $y = b$. \parencite{stewart2016}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Funcionlicon.png}
	\caption{Funciones lineal y constante}
	\label{Funcionlinealconst}
\end{figure}

\subsection{La prueba de la recta vertical}

La gráfica de una función es una curva en el plano $xy$. Pero surge la pregunta. ¿Cuáles curvas del plano $xy$ son gráficas de funciones? ESto se contesta por medio de la prueba siguiente. \parencite{stewart2016}

\begin{tcolorbox}
	Una curva en el plano de coordenadas es la gráfica de una función si y sólo si ninguna recta vertical cruza la curva más de una vez.
\end{tcolorbox}

Podemos ver la \hyperref[Pruebavertical]{\textbf{Figura~\ref*{Pruebavertical}}} para entender por qué la Prueba de la Recta Vertical es verdadera. 
Si cada recta vertical \(x = a\) cruza la curva sólo una vez en \((a,b)\), entonces exactamente un valor funcional está definido por \(f(a) = b\). 
Pero si una recta \(x = a\) cruza la curva dos veces, en \((a,b)\) y en \((a,c)\), entonces la curva no puede representar una función 
porque una función no puede asignar dos valores diferentes a \(a\).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{Figuras/Pruebavertical.png}
	\caption{Prueba de la recta vertical}
	\label{Pruebavertical}
\end{figure}

\section{Aplicación}

Se presentará un código en \textbf{Python} que sea capaz de graficar funciones, según los datos de entrada que se pidan.

\begin{pythoncode}
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# === Ingreso de la función por el usuario ===
expr_str = input("Ingrese la función en términos de x (ejemplo: sin(x), x**2 + 3*x - 5, exp(-x)*cos(x)): ")

# === Definición de variable simbólica ===
x = sp.Symbol('x')

# === Conversión del texto a expresión simbólica ===
try:
expr = sp.sympify(expr_str)
except sp.SympifyError:
print("Error: la función ingresada no es válida.")
exit()

# === Creación de función numérica evaluable ===
f = sp.lambdify(x, expr, modules=['numpy'])

# === Intervalo de graficación ===
x_vals = np.linspace(-10, 10, 400)
y_vals = f(x_vals)

# === Graficar ===
plt.figure(figsize=(7,5))
plt.plot(x_vals, y_vals, label=f"$f(x) = {sp.latex(expr)}$", color='navy')
plt.title("Gráfica de la función ingresada", fontsize=13)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True, linestyle='--', alpha=0.6)
plt.axhline(0, color='black', linewidth=1)
plt.axvline(0, color='black', linewidth=1)
plt.legend()
plt.show()
\end{pythoncode}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{Figuras/FunPython.png}
	\caption{Graficando funciones con Python}
	\label{FunPy}
\end{figure}

\chapter{Restricciones}

Las restricciones son condiciones que limitan el conjunto de valores posibles que pueden tomar las variables en un problema matemático. Estas limitaciones definen el espacio factible o región factible, dentro del cual se busca una o más soluciones que cumplan con determinados criterios. Las restricciones pueden ser igualdades (por ejemplo, $x + y = 10$) o desigualdades (por ejemplo, $x \ge 0$), y desempeñan un papel fundamental en los problemas de optimización, programación lineal y análisis numérico.
\parencite{chapra2015}

Un sistema de ecuaciones consiste en un conjunto de ecuaciones que comparten las mismas variables. Resolverlo implica encontrar los valores que satisfacen todas las ecuaciones simultáneamente. Estos sistemas pueden clasificarse en lineales y no lineales, y sus métodos de resolución varían desde técnicas algebraicas clásicas (como la sustitución o igualación) hasta procedimientos numéricos avanzados (como el método de Gauss-Seidel o Newton-Raphson).
\parencite{chapra2015}

En el contexto de la programación numérica, las restricciones se representan y manipulan mediante código, permitiendo no solo resolver el sistema de ecuaciones sino también visualizar gráficamente la región factible y el punto óptimo. Esta representación es especialmente útil para comprender la interacción entre las ecuaciones y las limitaciones impuestas, facilitando el análisis y la toma de decisiones en problemas aplicados de ingeniería, economía y ciencias computacionales.
\parencite{chapra2015}

\section{Ejemplo}

Un desarrollador tiene 15 horas semanales para dedicar al desarrollo de software de front-end (x) y back-end (y). Además:

\begin{itemize}
	\item Debe dedicar al menos 5 horas al desarrollo de front-end para cumplir con los entregables del cliente.
	\item El tiempo total no puede exceder 15 horas por restricciones de tiempo del sprint.
\end{itemize}

Formule las restricciones, represéntelas gráficamente e identifique las combinaciones posibles de tiempo a invertir en cada actividad.

\textbf{Variables}

\begin{itemize}
	\item x = horas dedicadas al front-end
	\item y = horas dedicadas al back-end
\end{itemize}

\textbf{Restricciones}

\begin{enumerate}
	\item Debe dedicar al menos 5 horas al mes.
	\begin{itemize}
		\item $x \geq 5$
	\end{itemize}
	\item El tiempo total no puede exceder a 15 horas.
	\begin{itemize}
		\item $x + y \leq 15 $
	\end{itemize}
\end{enumerate}

\textbf{Gráfico generado con python}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.60\linewidth]{Figuras/Ejercicio1.png}
	\caption{Aplicación de restricciones en Python}
	\label{EjemploRestriccion}
\end{figure}

\textbf{Interpretación del gráfico}

En la representación gráfica se observa la región factible determinada por las restricciones planteadas:

\begin{itemize}
	\item $x \geq 5$: el desarrollador debe dedicar al menos 5 horas al front-end. Esta condición aparece como una línea vertical en $x=5$ y la región válida se encuentra a la derecha de ella.
	\item $y \geq 0$: el tiempo dedicado al back-end no puede ser negativo, por lo que la región se limita a la parte superior del eje $x$.
	\item $x + y \leq 15$: la suma de horas asignadas a front-end y back-end no puede superar las 15 horas semanales. Gráficamente, corresponde a la semirrecta bajo la línea $x+y=15$.
\end{itemize}

La intersección de estas tres restricciones genera una región triangular factible delimitada por los puntos $(5,0)$, $(15,0)$ y $(5,10)$. Esto significa que cualquier combinación de horas ubicada dentro o sobre este triángulo cumple con las condiciones del problema. Por ejemplo, el desarrollador podría dedicar:

\begin{itemize}
	\item 5 horas a front-end y 10 horas a back-end,
	\item 10 horas a front-end y 5 horas a back-end,
	\item o bien 15 horas únicamente a front-end.
\end{itemize}

En conclusión, la región sombreada representa todas las combinaciones posibles de tiempo de trabajo entre front-end y back-end que respetan tanto el mínimo requerido en front-end como la restricción máxima de 15 horas semanales.

\textbf{Código en Python}

\begin{pythoncode}
	# Función para preparar expresiones lineales
def preparar_expresion(expr: str) -> str:
expr = expr.replace(" ", "")          # quitar espacios
expr = expr.replace("^", "**")        # potencia
expr = expr.replace("-x", "-1*x")     # caso -x
expr = expr.replace("+x", "+1*x")     # caso +x
if expr.startswith("x"):              # si empieza con x
expr = "1*" + expr
expr = expr.replace("x", "*x")        # poner multiplicación
expr = expr.replace("**x", "*x")      # corregir si se duplicó
return expr

# Restricciones:
# 1) x = 5  (vertical)
# 2) x + y = 15  ->  y = -x + 15
func2 = preparar_expresion("-x+15")

# Rango de la gráfica
xmin, xmax = -5, 20
ymin, ymax = -5, 20

# Recorremos el plano
for y in range(ymax, ymin - 1, -1):
linea = ""
for x in range(xmin, xmax + 1):
# Recta 1: x = 5
cond1 = (x == 5)

# Recta 2: y = -x + 15
try:
y2 = eval(func2)
except:
y2 = None
cond2 = (y2 is not None and abs(y - y2) < 0.5)

# Región factible: x>=5, y>=0, x+y<=15
region = (x >= 5 and y >= 0 and x + y <= 15)

# Qué dibujar
if cond1 and cond2:
linea += "#"
elif cond1:
linea += "*"
elif cond2:
linea += "o"
elif x == 0 and y == 0:
linea += "+"
elif x == 0:
linea += "|"
elif y == 0:
linea += "-"
elif region:
linea += "."
else:
linea += " "
print(linea)

# Leyenda
print("\nLeyenda del gráfico:")
print("  * = x = 5")
print("  o = x + y = 15")
print("  # = Intersección")
print("  . = Región factible")
print("  | = Eje Y")
print("  - = Eje X")
print("  + = Origen (0,0)")
\end{pythoncode}

\chapter{Método de Newton Raphson}

El \textbf{método de Newton-Raphson} es una técnica iterativa utilizada para encontrar raíces de ecuaciones no lineales de la forma:
\[
f(x) = 0
\]
Es uno de los métodos más eficaces y ampliamente utilizados debido a su rapidez de convergencia cuando se cumplen las condiciones necesarias. Fue propuesto originalmente por Isaac Newton y posteriormente generalizado por Joseph Raphson \parencite{chapra2015}

\section{Fundamento teórico}

La idea básica del método consiste en aproximar la función $f(x)$ mediante su expansión de Taylor alrededor de un punto $x_i$ y despreciar los términos de orden superior:
\[
f(x) \approx f(x_i) + f'(x_i)(x - x_i)
\]

Para hallar la raíz, se hace $f(x) = 0$, y despejando $x$ se obtiene la fórmula iterativa:
\[
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
\]

Esta expresión permite calcular una mejor aproximación de la raíz en cada iteración. El proceso continúa hasta que el valor de $x_{i+1}$ converge a la raíz real con una tolerancia previamente establecida \parencite{chapra2015}

\section{Condiciones de convergencia}

El método de Newton-Raphson presenta convergencia cuadrática, es decir, el error disminuye aproximadamente al cuadrado en cada iteración, siempre que se cumplan las siguientes condiciones \parencite{sullivan2004}:

\begin{itemize}
	\item La función $f(x)$ es continua y derivable en un intervalo que contiene la raíz buscada.
	\item La derivada $f'(x)$ no se anula en el entorno de la raíz.
	\item La estimación inicial $x_0$ está suficientemente cerca de la raíz real.
\end{itemize}

Sin embargo, si $f'(x_i)$ se aproxima a cero o si la estimación inicial está muy alejada, el método puede divergir o generar oscilaciones \parencite{burden2016}.

\section{Criterio de parada}

El proceso iterativo se detiene cuando se cumple alguna de las siguientes condiciones \parencite{chapra2015}:

\begin{itemize}
	\item $|f(x_{i+1})| < \varepsilon$
	\item $|x_{i+1} - x_i| < \varepsilon$
\end{itemize}

donde $\varepsilon$ es la \textit{tolerancia} o el error máximo permitido.

\section{Algoritmo del método de Newton-Raphson}

\begin{tcolorbox}
	\begin{enumerate}
		\item Elegir una estimación inicial $x_0$.
		\item Calcular $f(x_0)$ y $f'(x_0)$.
		\item Evaluar:
		\[
		x_{1} = x_0 - \frac{f(x_0)}{f'(x_0)}
		\]
		\item Repetir el proceso:
		\[
		x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
		\]
		hasta que se cumpla el criterio de convergencia.
	\end{enumerate}
\end{tcolorbox}

\section{Aplicación del método en Python}

El objetivo fue desarrollar en el lenguaje de programación Python un programa que permita al usuario ingresar una función $f(x)$ y graficarla en un intervalo definido. Esta etapa inicial tiene como propósito ayudar al usuario a identificar visualmente las posibles raíces y decidir si desea aplicar el método de Newton-Raphson.

En caso afirmativo, el programa solicita un valor inicial $x_1$ basado en la observación de la gráfica y ejecuta el algoritmo iterativo de Newton-Raphson hasta que la diferencia entre dos aproximaciones sucesivas sea menor a una tolerancia predefinida. Finalmente, el programa muestra en pantalla la raíz aproximada encontrada y el número de iteraciones necesarias para alcanzarla.

Este enfoque combina la interpretación gráfica con el análisis numérico, promoviendo una comprensión más completa del comportamiento de la función y de la eficacia del método iterativo.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para evaluar si realizar o no el método.
	\item La raíz encontrada.
	\item Número de iteraciones realizadas hasta encontrar la raíz.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función y su derivada (usando derivada numérica)
def f(x):
return eval(func_str)

def f_prime(x, h=1e-6):  # derivada numérica
return (f(x + h) - f(x - h)) / (2 * h)

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar Newton-Raphson ===
op = input("¿Desea encontrar una raíz con el método de Newton-Raphson? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de punto inicial ===
x0 = float(input("Basado en la gráfica, ingrese el valor inicial x1: "))

# Parámetros del método
tol = 1e-6
max_iter = 100

# Iteraciones
for i in range(1, max_iter + 1):
fx = f(x0)
fpx = f_prime(x0)

if fpx == 0:
print(f"La derivada es cero en x = {x0}. El método no puede continuar.")
break

x1 = x0 - fx / fpx

# Verificar convergencia
if abs(x1 - x0) < tol:
print(f"\n✅ Raíz aproximada encontrada: {x1:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0 = x1
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")

else:
print("No se aplicó el método de Newton-Raphson.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Newthon2.png}
	\caption{Método de Newthon-Rapshon en Python}
	\label{Newthon-R}
\end{figure}

\chapter{Método de Bisección}

El método de bisección es uno de los algoritmos más simples, robustos y confiables para la localización de raíces de ecuaciones no lineales de la forma
\[
f(x)=0.
\]
Su fundamento teórico se basa en el \textbf{Teorema del Valor Intermedio}, el cual garantiza la existencia de una raíz siempre que la función sea continua en un intervalo cerrado $[a,b]$ y que se cumpla la condición
\[
f(a)\, f(b) < 0.
\]
Esto indica que en el intervalo ocurre un cambio de signo y, por tanto, debe existir al menos una raíz en su interior \parencite{burden2016}.

\subsection{Idea fundamental del método}

El método consiste en dividir sucesivamente el intervalo $[a,b]$ por su punto medio. Si llamamos
\[
c = \frac{a+b}{2},
\]
entonces evaluamos $f(c)$ y determinamos en qué subintervalo persiste el cambio de signo:

\begin{itemize}
	\item Si $f(a)\, f(c) < 0$, la raíz se encuentra en $[a,c]$.
	\item Si $f(c)\, f(b) < 0$, la raíz se encuentra en $[c,b]$.
\end{itemize}

Este proceso se repite recursivamente, produciendo intervalos cada vez más pequeños. Debido a su naturaleza, el método \textbf{siempre converge} cuando la función es continua y se inicia con un intervalo válido, aunque la convergencia es relativamente lenta \parencite{chapra2015}.

\subsection{Criterios de parada}

El método se detiene cuando se cumple alguna de las siguientes condiciones:

\begin{enumerate}
	\item El ancho del intervalo es menor que una tolerancia establecida:
	\[
	|b-a| < \varepsilon.
	\]
	\item El valor funcional es cercano a cero:
	\[
	|f(c)| < \delta.
	\]
	\item Se alcanza un número máximo de iteraciones:
	\[
	n \ge n_{\max}.
	\]
\end{enumerate}

El error después de $n$ iteraciones está acotado por
\[
|x - c_n| \le \frac{b-a}{2^n},
\]
lo cual permite estimar de manera precisa el número de pasos necesarios para obtener una tolerancia deseada \parencite{suli2003}.

\subsection{Ventajas del método}

El método de bisección posee varias ventajas importantes:

\begin{itemize}
	\item Garantiza convergencia siempre que exista un cambio de signo en el intervalo.
	\item Es simple de implementar.
	\item Permite una estimación directa del error en cada iteración.
	\item Es estable numéricamente y no requiere derivadas.
\end{itemize}

Estas características lo convierten en un método ideal para iniciar procesos de localización de raíces o para validar aproximaciones obtenidas mediante métodos más rápidos pero menos robustos, como Newton-Raphson o la secante \parencite{press2007}.

\subsection{Desventajas}

A pesar de su robustez, el método de bisección presenta algunas limitaciones:

\begin{itemize}
	\item La convergencia es lineal y relativamente lenta en comparación con otros métodos.
	\item Requiere conocer un intervalo donde la función cambie de signo.
	\item No obtiene raíces múltiples o raíces donde la función no cambia de signo.
\end{itemize}

Aun así, su combinación de simplicidad y fiabilidad lo convierte en un método fundamental dentro de los algoritmos de análisis numérico \parencite{burden2016}.

\section{Aplicación del método en Python}

Se desarrolló en Python un programa que permite al usuario ingresar una función matemática y visualizar su gráfico en un intervalo definido. Esta etapa inicial facilita la elección del intervalo $[a,b]$ donde la función cambia de signo.

Una vez seleccionado el intervalo, el programa ejecuta el método de bisección iterativamente, mostrando en pantalla una tabla con los valores de $a$, $b$, $c$, $f(c)$ y el error de cada iteración. El proceso finaliza cuando se cumple la condición de tolerancia o se alcanza el número máximo de iteraciones. Finalmente, se presenta la raíz aproximada encontrada.

Este enfoque combina el análisis gráfico con la interpretación numérica, permitiendo comprender mejor el comportamiento de la función y la estabilidad del método.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para evaluar el intervalo de búsqueda.
	\item Tabla con las iteraciones del método.
	\item Raíz aproximada y número de iteraciones realizadas.
\end{itemize}

\textbf{Restricciones}

El método requiere que:
\begin{itemize}
	\item $f(x)$ sea continua en el intervalo $[a,b]$.
	\item Se cumpla la condición $f(a)\cdot f(b) < 0$.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función
def f(x):
return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de Bisección ===
op = input("¿Desea encontrar una raíz con el método de Bisección? (s/n): ").lower()

if op == "s":
# === 4. Ingreso del intervalo inicial ===
a = float(input("Ingrese el extremo izquierdo del intervalo (a): "))
b = float(input("Ingrese el extremo derecho del intervalo (b): "))

# Verificación del cambio de signo
if f(a) * f(b) > 0:
print("\n⚠️ No hay cambio de signo en el intervalo [a, b]. Intente con otro intervalo.")
else:
# Parámetros del método
tol = 1e-6
max_iter = 100

print("\nIteración |     a       |      b       |      c       |    f(c)     |   Error")
print("----------------------------------------------------------------")

for i in range(1, max_iter + 1):
c = (a + b) / 2
fc = f(c)
error = abs(b - a) / 2

print(f"{i:9d} | {a:10.6f} | {b:10.6f} | {c:10.6f} | {fc:10.6f} | {error:10.6f}")

if abs(fc) < tol or error < tol:
print(f"\n✅ Raíz aproximada encontrada: {c:.6f}")
print(f"Iteraciones realizadas: {i}")
break

if f(a) * fc < 0:
b = c
else:
a = c
else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de Bisección.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Biseccion1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Biseccion2.png}
	\caption{Método de Bisección en Python}
	\label{Biseccion}
\end{figure}

\chapter{Método de la Secante}

El método de la secante es una técnica numérica ampliamente utilizada para la resolución de ecuaciones no lineales, especialmente en contextos donde la derivada de la función no está disponible o resulta difícil de calcular. A diferencia del método de Newton–Raphson, que requiere la evaluación explícita de la derivada, la secante se basa en una aproximación numérica de la misma utilizando dos puntos consecutivos de la función \parencite{burden2011,chapra2015}. 

\subsection{Fundamento teórico}

El método surge de la idea de aproximar la derivada de la función mediante un cociente incremental, reemplazando la derivada verdadera por:

\[
f'(x_n) \approx \frac{f(x_n)-f(x_{n-1})}{x_n - x_{n-1}}.
\]

Sustituyendo esta expresión en la fórmula de Newton--Raphson se obtiene la iteración del método de la secante:

\[
x_{n+1} = x_n - f(x_n)\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.
\]

La deducción formal y el análisis matemático del método pueden consultarse en textos clásicos de análisis numérico \parencite{burden2011}, así como en manuales modernos de métodos computacionales \parencite{chapra2015,atkinson2009}.

\subsection{Interpretación geométrica}

Geométricamente, el método consiste en trazar la recta secante que pasa por los puntos \((x_{n-1}, f(x_{n-1}))\) y \((x_n, f(x_n))\), y encontrar su intersección con el eje \(x\). Esta construcción geométrica proporciona una aproximación sucesiva a la raíz de la ecuación \(f(x)=0\) \parencite{sullivan2004}.

La secante generada en cada iteración reemplaza el uso de la tangente del método de Newton, permitiendo que el método avance sin necesidad de calcular derivadas. Esta propiedad convierte a la secante en un algoritmo eficiente en problemas aplicados donde la evaluación de \(f'(x)\) puede ser costosa o inestable \parencite{cheney2009}.

\subsection{Convergencia}

El método posee una convergencia superlineal, cuya razón de convergencia es aproximadamente \(1.618\), el número áureo. Aunque es menos rápido que Newton–Raphson, suele ser más eficiente cuando la derivada no está disponible o cuando su cálculo es propenso a errores numéricos \parencite{atkinson2009}. Sin embargo, su éxito requiere seleccionar dos valores iniciales adecuados para evitar divisiones entre valores de función muy pequeños o iteraciones divergentes \parencite{burden2011}.

\subsection{Ventajas y limitaciones}

Entre sus principales ventajas destacan:

\begin{itemize}
	\item No requiere el cálculo de la derivada de la función.
	\item Tiende a ser más estable que Newton–Raphson cuando la derivada es difícil de evaluar.
	\item Posee una tasa de convergencia superior al método de bisección.
\end{itemize}

Sus principales limitaciones incluyen:

\begin{itemize}
	\item No garantiza convergencia global.
	\item Requiere dos valores iniciales definidos.
	\item Puede divergir si los valores iniciales no son adecuados o si la función presenta discontinuidades o múltiples raíces cercanas.
\end{itemize}

Para un análisis detallado de sus propiedades teóricas y aplicaciones prácticas pueden consultarse referencias especializadas en análisis numérico \parencite{burden2011,chapra2015,atkinson2009,cheney2009}.

\section{Aplicación del método en Python}

Se desarrolló un programa en Python que permite al usuario ingresar una función $f(x)$ y graficarla en un intervalo definido. Esta etapa inicial facilita la identificación visual de posibles raíces y la selección de los valores iniciales $x_0$ y $x_1$.

Luego, el programa aplica el método de la secante iterativamente hasta alcanzar una tolerancia establecida o un número máximo de iteraciones. En cada iteración, se muestran los valores de $x_0$, $x_1$, $f(x_0)$, $f(x_1)$, la nueva aproximación $x_2$ y el error absoluto. Finalmente, se imprime la raíz aproximada encontrada y el número de iteraciones necesarias.

Este procedimiento combina la exploración gráfica con el razonamiento numérico, fomentando una comprensión más completa de la convergencia y del comportamiento de la función.

\textbf{Entrada}

Una cadena de texto que representa una función matemática.

\begin{align*}
	f(x) = x^3 - x - 1
\end{align*}

\textbf{Salida}

\begin{itemize}
	\item Gráfica para visualizar la función y elegir los puntos iniciales.
	\item Tabla con los valores de cada iteración.
	\item Raíz aproximada y número de iteraciones necesarias.
\end{itemize}

\textbf{Restricciones}

\begin{itemize}
	\item $f(x)$ debe ser continua en el intervalo analizado.
	\item Los valores iniciales $x_0$ y $x_1$ deben ser distintos y cercanos a la raíz.
\end{itemize}

\textbf{Código}

\begin{pythoncode}
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la función ===
func_str = input("Ingrese la función f(x): ")  # Ejemplo: x**3 - x - 1

# Definimos la función
def f(x):
return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la función ===
xmin = float(input("Ingrese el valor mínimo de x: "))
xmax = float(input("Ingrese el valor máximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gráfico de la función ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el método de la secante ===
op = input("¿Desea encontrar una raíz con el método de la Secante? (s/n): ").lower()

if op == "s":
# === 4. Ingreso de puntos iniciales ===
x0 = float(input("Ingrese el primer valor inicial x0: "))
x1 = float(input("Ingrese el segundo valor inicial x1: "))

# Parámetros del método
tol = 1e-6
max_iter = 100

print("\nIteración |     x0      |      x1      |     f(x0)     |     f(x1)     |     x2      |   Error")
print("----------------------------------------------------------------------")

for i in range(1, max_iter + 1):
f0 = f(x0)
f1 = f(x1)

if f1 - f0 == 0:
print(f"\n⚠️ División por cero en la iteración {i}. El método no puede continuar.")
break

x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
error = abs(x2 - x1)

print(f"{i:9d} | {x0:10.6f} | {x1:10.6f} | {f0:12.6f} | {f1:12.6f} | {x2:10.6f} | {error:10.6f}")

if error < tol:
print(f"\n✅ Raíz aproximada encontrada: {x2:.6f}")
print(f"Iteraciones realizadas: {i}")
break

x0, x1 = x1, x2

else:
print("\n⚠️ No se alcanzó la convergencia después de", max_iter, "iteraciones.")
else:
print("No se aplicó el método de la Secante.")
\end{pythoncode}

\textbf{Ejecución}

\begin{figure} [htbp]
	\centering
	\includegraphics[width=0.75\linewidth]{Figuras/Secante1.png}
	\includegraphics[width=0.75\linewidth]{Figuras/Secante2.png}
	\caption{Método de la Secante en Python}
	\label{Secante}
\end{figure}

\chapter{Método de Punto Fijo}

\chapter{Método de Regula Falsi}